"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vercel+blob@0.22.3";
exports.ids = ["vendor-chunks/@vercel+blob@0.22.3"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/chunk-IDKCY4S2.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/chunk-IDKCY4S2.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: () => (/* binding */ BlobAccessError),\n/* harmony export */   BlobError: () => (/* binding */ BlobError),\n/* harmony export */   BlobNotFoundError: () => (/* binding */ BlobNotFoundError),\n/* harmony export */   BlobServiceNotAvailable: () => (/* binding */ BlobServiceNotAvailable),\n/* harmony export */   BlobStoreNotFoundError: () => (/* binding */ BlobStoreNotFoundError),\n/* harmony export */   BlobStoreSuspendedError: () => (/* binding */ BlobStoreSuspendedError),\n/* harmony export */   BlobUnknownError: () => (/* binding */ BlobUnknownError),\n/* harmony export */   createCompleteMultipartUploadMethod: () => (/* binding */ createCompleteMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploadMethod: () => (/* binding */ createCreateMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploaderMethod: () => (/* binding */ createCreateMultipartUploaderMethod),\n/* harmony export */   createPutMethod: () => (/* binding */ createPutMethod),\n/* harmony export */   createUploadPartMethod: () => (/* binding */ createUploadPartMethod),\n/* harmony export */   getDownloadUrl: () => (/* binding */ getDownloadUrl),\n/* harmony export */   getTokenFromOptionsOrEnv: () => (/* binding */ getTokenFromOptionsOrEnv),\n/* harmony export */   requestApi: () => (/* binding */ requestApi)\n/* harmony export */ });\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! undici */ \"(rsc)/./node_modules/.pnpm/undici@5.29.0/node_modules/undici/index.js\");\n/* harmony import */ var async_retry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! async-retry */ \"(rsc)/./node_modules/.pnpm/async-retry@1.3.3/node_modules/async-retry/lib/index.js\");\n/* harmony import */ var bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bytes */ \"(rsc)/./node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! is-buffer */ \"(rsc)/./node_modules/.pnpm/is-buffer@2.0.5/node_modules/is-buffer/index.js\");\n// src/helpers.ts\nfunction getTokenFromOptionsOrEnv(options) {\n  if (options == null ? void 0 : options.token) {\n    return options.token;\n  }\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n  throw new BlobError(\n    \"No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.\"\n  );\n}\nvar BlobError = class extends Error {\n  constructor(message) {\n    super(`Vercel Blob: ${message}`);\n  }\n};\nfunction getDownloadUrl(blobUrl) {\n  const url = new URL(blobUrl);\n  url.searchParams.set(\"download\", \"1\");\n  return url.toString();\n}\n\n// src/api.ts\n\n\n\n// src/debug.ts\nvar debugIsActive = false;\nvar _a, _b;\ntry {\n  if (((_a = process.env.DEBUG) == null ? void 0 : _a.includes(\"blob\")) || ((_b = process.env.NEXT_PUBLIC_DEBUG) == null ? void 0 : _b.includes(\"blob\"))) {\n    debugIsActive = true;\n  }\n} catch (error) {\n}\nfunction debug(message, ...args) {\n  if (debugIsActive) {\n    console.debug(`vercel-blob: ${message}`, ...args);\n  }\n}\n\n// src/api.ts\nvar BlobAccessError = class extends BlobError {\n  constructor() {\n    super(\"Access denied, please provide a valid token for this resource.\");\n  }\n};\nvar BlobStoreNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"This store does not exist.\");\n  }\n};\nvar BlobStoreSuspendedError = class extends BlobError {\n  constructor() {\n    super(\"This store has been suspended.\");\n  }\n};\nvar BlobUnknownError = class extends BlobError {\n  constructor() {\n    super(\"Unknown error, please visit https://vercel.com/help.\");\n  }\n};\nvar BlobNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"The requested blob does not exist\");\n  }\n};\nvar BlobServiceNotAvailable = class extends BlobError {\n  constructor() {\n    super(\"The blob service is currently not available. Please try again.\");\n  }\n};\nvar BlobServiceRateLimited = class extends BlobError {\n  constructor(seconds) {\n    super(\n      `Too many requests please lower the number of concurrent requests ${seconds ? ` - try again in ${seconds} seconds` : \"\"}.`\n    );\n    this.retryAfter = seconds != null ? seconds : 0;\n  }\n};\nvar BLOB_API_VERSION = 7;\nfunction getApiVersion() {\n  let versionOverride = null;\n  try {\n    versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n  }\n  return `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`;\n}\nfunction getApiUrl(pathname = \"\") {\n  let baseUrl = null;\n  try {\n    baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n  }\n  return `${baseUrl || \"https://blob.vercel-storage.com\"}${pathname}`;\n}\nfunction getRetries() {\n  try {\n    const retries = process.env.VERCEL_BLOB_RETRIES || \"10\";\n    return parseInt(retries, 10);\n  } catch {\n    return 10;\n  }\n}\nfunction createBlobServiceRateLimited(response) {\n  const retryAfter = response.headers.get(\"retry-after\");\n  return new BlobServiceRateLimited(\n    retryAfter ? parseInt(retryAfter, 10) : void 0\n  );\n}\nasync function getBlobError(response) {\n  var _a2, _b2, _c;\n  let code;\n  let message;\n  try {\n    const data = await response.json();\n    code = (_b2 = (_a2 = data.error) == null ? void 0 : _a2.code) != null ? _b2 : \"unknown_error\";\n    message = (_c = data.error) == null ? void 0 : _c.message;\n  } catch {\n    code = \"unknown_error\";\n  }\n  let error;\n  switch (code) {\n    case \"store_suspended\":\n      error = new BlobStoreSuspendedError();\n      break;\n    case \"forbidden\":\n      error = new BlobAccessError();\n      break;\n    case \"not_found\":\n      error = new BlobNotFoundError();\n      break;\n    case \"store_not_found\":\n      error = new BlobStoreNotFoundError();\n      break;\n    case \"bad_request\":\n      error = new BlobError(message != null ? message : \"Bad request\");\n      break;\n    case \"service_unavailable\":\n      error = new BlobServiceNotAvailable();\n      break;\n    case \"rate_limited\":\n      error = createBlobServiceRateLimited(response);\n      break;\n    case \"unknown_error\":\n    case \"not_allowed\":\n    default:\n      error = new BlobUnknownError();\n      break;\n  }\n  return { code, error };\n}\nasync function requestApi(pathname, init, commandOptions) {\n  const apiVersion = getApiVersion();\n  const token = getTokenFromOptionsOrEnv(commandOptions);\n  const apiResponse = await async_retry__WEBPACK_IMPORTED_MODULE_1__(\n    async (bail) => {\n      const res = await (0,undici__WEBPACK_IMPORTED_MODULE_0__.fetch)(getApiUrl(pathname), {\n        ...init,\n        headers: {\n          \"x-api-version\": apiVersion,\n          authorization: `Bearer ${token}`,\n          ...init.headers\n        }\n      });\n      if (res.ok) {\n        return res;\n      }\n      const { code, error } = await getBlobError(res);\n      if (code === \"unknown_error\" || code === \"service_unavailable\") {\n        throw error;\n      }\n      bail(error);\n    },\n    {\n      retries: getRetries(),\n      onRetry: (error) => {\n        debug(`retrying API request to ${pathname}`, error.message);\n      }\n    }\n  );\n  if (!apiResponse) {\n    throw new BlobUnknownError();\n  }\n  return await apiResponse.json();\n}\n\n// src/put-helpers.ts\nvar putOptionHeaderMap = {\n  cacheControlMaxAge: \"x-cache-control-max-age\",\n  addRandomSuffix: \"x-add-random-suffix\",\n  contentType: \"x-content-type\"\n};\nfunction createPutHeaders(allowedOptions, options) {\n  const headers = {};\n  if (allowedOptions.includes(\"contentType\") && options.contentType) {\n    headers[putOptionHeaderMap.contentType] = options.contentType;\n  }\n  if (allowedOptions.includes(\"addRandomSuffix\") && options.addRandomSuffix !== void 0) {\n    headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (allowedOptions.includes(\"cacheControlMaxAge\") && options.cacheControlMaxAge !== void 0) {\n    headers[putOptionHeaderMap.cacheControlMaxAge] = options.cacheControlMaxAge.toString();\n  }\n  return headers;\n}\nasync function createPutOptions({\n  pathname,\n  options,\n  extraChecks,\n  getToken\n}) {\n  if (!pathname) {\n    throw new BlobError(\"pathname is required\");\n  }\n  if (!options) {\n    throw new BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new BlobError('access must be \"public\"');\n  }\n  if (extraChecks) {\n    extraChecks(options);\n  }\n  if (getToken) {\n    options.token = await getToken(pathname, options);\n  }\n  return options;\n}\n\n// src/multipart/complete.ts\nfunction createCompleteMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, parts, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    return completeMultipartUpload({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      headers,\n      options,\n      parts\n    });\n  };\n}\nasync function completeMultipartUpload({\n  uploadId,\n  key,\n  pathname,\n  parts,\n  headers,\n  options\n}) {\n  try {\n    const response = await requestApi(\n      `/mpu/${pathname}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"content-type\": \"application/json\",\n          \"x-mpu-action\": \"complete\",\n          \"x-mpu-upload-id\": uploadId,\n          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n          // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n          \"x-mpu-key\": encodeURI(key)\n        },\n        body: JSON.stringify(parts)\n      },\n      options\n    );\n    debug(\"mpu: complete\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\n// src/multipart/create.ts\nfunction createCreateMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId\n    };\n  };\n}\nasync function createMultipartUpload(pathname, headers, options) {\n  debug(\"mpu: create\", \"pathname:\", pathname);\n  try {\n    const response = await requestApi(\n      `/mpu/${pathname}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"x-mpu-action\": \"create\"\n        }\n      },\n      options\n    );\n    debug(\"mpu: create\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\n// src/multipart/upload.ts\n\nfunction createUploadPartMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, body, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const result = await uploadPart({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      part: { blob: body, partNumber: options.partNumber },\n      headers,\n      options,\n      abortController: options.abortController\n    });\n    return {\n      etag: result.etag,\n      partNumber: options.partNumber\n    };\n  };\n}\nfunction uploadPart({\n  uploadId,\n  key,\n  pathname,\n  headers,\n  options,\n  abortController,\n  part\n}) {\n  return requestApi(\n    `/mpu/${pathname}`,\n    {\n      signal: abortController == null ? void 0 : abortController.signal,\n      method: \"POST\",\n      headers: {\n        ...headers,\n        \"x-mpu-action\": \"upload\",\n        \"x-mpu-key\": encodeURI(key),\n        \"x-mpu-upload-id\": uploadId,\n        \"x-mpu-part-number\": part.partNumber.toString()\n      },\n      // weird things between undici types and native fetch types\n      body: part.blob,\n      // required in order to stream some body types to Cloudflare\n      // currently only supported in Node.js, we may have to feature detect this\n      duplex: \"half\"\n    },\n    options\n  );\n}\nvar maxConcurrentUploads = typeof window !== \"undefined\" ? 6 : 8;\nvar partSizeInBytes = 8 * 1024 * 1024;\nvar maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\nfunction uploadAllParts({\n  uploadId,\n  key,\n  pathname,\n  stream,\n  headers,\n  options\n}) {\n  debug(\"mpu: upload init\", \"key:\", key);\n  const internalAbortController = new AbortController();\n  return new Promise((resolve, reject) => {\n    const partsToUpload = [];\n    const completedParts = [];\n    const reader = stream.getReader();\n    let activeUploads = 0;\n    let reading = false;\n    let currentPartNumber = 1;\n    let rejected = false;\n    let currentBytesInMemory = 0;\n    let doneReading = false;\n    let bytesSent = 0;\n    let arrayBuffers = [];\n    let currentPartBytesRead = 0;\n    read().catch(cancel);\n    async function read() {\n      debug(\n        \"mpu: upload read start\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_2__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_2__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_2__(bytesSent)\n      );\n      reading = true;\n      while (currentBytesInMemory < maxBytesInMemory && !rejected) {\n        try {\n          const { value, done } = await reader.read();\n          if (done) {\n            doneReading = true;\n            debug(\"mpu: upload read consumed the whole stream\");\n            if (arrayBuffers.length > 0) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              sendParts();\n            }\n            reading = false;\n            return;\n          }\n          currentBytesInMemory += value.byteLength;\n          let valueOffset = 0;\n          while (valueOffset < value.byteLength) {\n            const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n            const endOffset = Math.min(\n              valueOffset + remainingPartSize,\n              value.byteLength\n            );\n            const chunk = value.slice(valueOffset, endOffset);\n            arrayBuffers.push(chunk);\n            currentPartBytesRead += chunk.byteLength;\n            valueOffset = endOffset;\n            if (currentPartBytesRead === partSizeInBytes) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              arrayBuffers = [];\n              currentPartBytesRead = 0;\n              sendParts();\n            }\n          }\n        } catch (error) {\n          cancel(error);\n        }\n      }\n      debug(\n        \"mpu: upload read end\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_2__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_2__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_2__(bytesSent)\n      );\n      reading = false;\n    }\n    async function sendPart(part) {\n      activeUploads++;\n      debug(\n        \"mpu: upload send part start\",\n        \"partNumber:\",\n        part.partNumber,\n        \"size:\",\n        part.blob.size,\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_2__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_2__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_2__(bytesSent)\n      );\n      try {\n        const completedPart = await uploadPart({\n          uploadId,\n          key,\n          pathname,\n          headers,\n          options,\n          abortController: internalAbortController,\n          part\n        });\n        debug(\n          \"mpu: upload send part end\",\n          \"partNumber:\",\n          part.partNumber,\n          \"activeUploads\",\n          activeUploads,\n          \"currentBytesInMemory:\",\n          `${bytes__WEBPACK_IMPORTED_MODULE_2__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_2__(maxBytesInMemory)}`,\n          \"bytesSent:\",\n          bytes__WEBPACK_IMPORTED_MODULE_2__(bytesSent)\n        );\n        if (rejected) {\n          return;\n        }\n        completedParts.push({\n          partNumber: part.partNumber,\n          etag: completedPart.etag\n        });\n        currentBytesInMemory -= part.blob.size;\n        activeUploads--;\n        bytesSent += part.blob.size;\n        if (partsToUpload.length > 0) {\n          sendParts();\n        }\n        if (doneReading) {\n          if (activeUploads === 0) {\n            reader.releaseLock();\n            resolve(completedParts);\n          }\n          return;\n        }\n        if (!reading) {\n          read().catch(cancel);\n        }\n      } catch (error) {\n        cancel(error);\n      }\n    }\n    function sendParts() {\n      if (rejected) {\n        return;\n      }\n      debug(\n        \"send parts\",\n        \"activeUploads\",\n        activeUploads,\n        \"partsToUpload\",\n        partsToUpload.length\n      );\n      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {\n        const partToSend = partsToUpload.shift();\n        if (partToSend) {\n          void sendPart(partToSend);\n        }\n      }\n    }\n    function cancel(error) {\n      if (rejected) {\n        return;\n      }\n      rejected = true;\n      internalAbortController.abort();\n      reader.releaseLock();\n      if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n        reject(new BlobServiceNotAvailable());\n      } else {\n        reject(error);\n      }\n    }\n  });\n}\n\n// src/multipart/helpers.ts\n\n\nfunction toReadableStream(value) {\n  if (value instanceof ReadableStream) {\n    return value;\n  }\n  if (value instanceof Blob) {\n    return value.stream();\n  }\n  if (isNodeJsReadableStream(value)) {\n    return stream__WEBPACK_IMPORTED_MODULE_3__.Readable.toWeb(value);\n  }\n  let streamValue;\n  if (value instanceof ArrayBuffer) {\n    streamValue = value;\n  } else if (isNodeJsBufferOrString(value)) {\n    streamValue = value.buffer;\n  } else {\n    streamValue = stringToUint8Array(value);\n  }\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(streamValue);\n      controller.close();\n    }\n  });\n}\nfunction isNodeJsReadableStream(value) {\n  return typeof value === \"object\" && typeof value.pipe === \"function\" && value.readable && typeof value._read === \"function\" && // @ts-expect-error _readableState does exists on Readable\n  typeof value._readableState === \"object\";\n}\nfunction stringToUint8Array(s) {\n  const enc = new TextEncoder();\n  return enc.encode(s);\n}\nfunction isNodeJsBufferOrString(input) {\n  return is_buffer__WEBPACK_IMPORTED_MODULE_4__(input);\n}\n\n// src/multipart/uncontrolled.ts\nasync function uncontrolledMultipartUpload(pathname, body, headers, options) {\n  debug(\"mpu: init\", \"pathname:\", pathname, \"headers:\", headers);\n  const stream = toReadableStream(body);\n  const createMultipartUploadResponse = await createMultipartUpload(\n    pathname,\n    headers,\n    options\n  );\n  const parts = await uploadAllParts({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    stream,\n    headers,\n    options\n  });\n  const blob = await completeMultipartUpload({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    parts,\n    headers,\n    options\n  });\n  return blob;\n}\n\n// src/put.ts\nfunction createPutMethod({\n  allowedOptions,\n  getToken,\n  extraChecks\n}) {\n  return async function put(pathname, bodyOrOptions, optionsInput) {\n    const isFolderCreation = pathname.endsWith(\"/\");\n    if (!bodyOrOptions && !isFolderCreation) {\n      throw new BlobError(\"body is required\");\n    }\n    if (bodyOrOptions && optionsInput && isFolderCreation) {\n      throw new BlobError(\"body is not allowed for creating empty folders\");\n    }\n    const body = isFolderCreation ? void 0 : bodyOrOptions;\n    const options = await createPutOptions({\n      pathname,\n      // when no body is required (for folder creations) options are the second argument\n      options: isFolderCreation ? bodyOrOptions : optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (options.multipart === true && body) {\n      return uncontrolledMultipartUpload(pathname, body, headers, options);\n    }\n    const response = await requestApi(\n      `/${pathname}`,\n      {\n        method: \"PUT\",\n        body,\n        headers,\n        // required in order to stream some body types to Cloudflare\n        // currently only supported in Node.js, we may have to feature detect this\n        duplex: \"half\"\n      },\n      options\n    );\n    return {\n      url: response.url,\n      downloadUrl: response.downloadUrl,\n      pathname: response.pathname,\n      contentType: response.contentType,\n      contentDisposition: response.contentDisposition\n    };\n  };\n}\n\n// src/multipart/create-uploader.ts\nfunction createCreateMultipartUploaderMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n      async uploadPart(partNumber, body) {\n        const result = await uploadPart({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          part: { partNumber, blob: body },\n          headers,\n          options\n        });\n        return {\n          etag: result.etag,\n          partNumber\n        };\n      },\n      async complete(parts) {\n        return completeMultipartUpload({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          parts,\n          headers,\n          options\n        });\n      }\n    };\n  };\n}\n\n\n//# sourceMappingURL=chunk-IDKCY4S2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZlcmNlbCtibG9iQDAuMjIuMy9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2h1bmstSURLQ1k0UzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDK0I7QUFDQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw2QkFBNkIsU0FBUyxjQUFjO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFlBQVksNkRBQTZEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxZQUFZLDZDQUE2QyxFQUFFLFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQWtCRTtBQUNGIiwic291cmNlcyI6WyJDOlxccHJvamVjdHNcXGF1dGhcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEB2ZXJjZWwrYmxvYkAwLjIyLjNcXG5vZGVfbW9kdWxlc1xcQHZlcmNlbFxcYmxvYlxcZGlzdFxcY2h1bmstSURLQ1k0UzIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2hlbHBlcnMudHNcbmZ1bmN0aW9uIGdldFRva2VuRnJvbU9wdGlvbnNPckVudihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRva2VuKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudG9rZW47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52LkJMT0JfUkVBRF9XUklURV9UT0tFTikge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5CTE9CX1JFQURfV1JJVEVfVE9LRU47XG4gIH1cbiAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICBcIk5vIHRva2VuIGZvdW5kLiBFaXRoZXIgY29uZmlndXJlIHRoZSBgQkxPQl9SRUFEX1dSSVRFX1RPS0VOYCBlbnZpcm9ubWVudCB2YXJpYWJsZSwgb3IgcGFzcyBhIGB0b2tlbmAgb3B0aW9uIHRvIHlvdXIgY2FsbHMuXCJcbiAgKTtcbn1cbnZhciBCbG9iRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKGBWZXJjZWwgQmxvYjogJHttZXNzYWdlfWApO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0RG93bmxvYWRVcmwoYmxvYlVybCkge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKGJsb2JVcmwpO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldChcImRvd25sb2FkXCIsIFwiMVwiKTtcbiAgcmV0dXJuIHVybC50b1N0cmluZygpO1xufVxuXG4vLyBzcmMvYXBpLnRzXG5pbXBvcnQgeyBmZXRjaCB9IGZyb20gXCJ1bmRpY2lcIjtcbmltcG9ydCByZXRyeSBmcm9tIFwiYXN5bmMtcmV0cnlcIjtcblxuLy8gc3JjL2RlYnVnLnRzXG52YXIgZGVidWdJc0FjdGl2ZSA9IGZhbHNlO1xudmFyIF9hLCBfYjtcbnRyeSB7XG4gIGlmICgoKF9hID0gcHJvY2Vzcy5lbnYuREVCVUcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhcImJsb2JcIikpIHx8ICgoX2IgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19ERUJVRykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwiYmxvYlwiKSkpIHtcbiAgICBkZWJ1Z0lzQWN0aXZlID0gdHJ1ZTtcbiAgfVxufSBjYXRjaCAoZXJyb3IpIHtcbn1cbmZ1bmN0aW9uIGRlYnVnKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcbiAgaWYgKGRlYnVnSXNBY3RpdmUpIHtcbiAgICBjb25zb2xlLmRlYnVnKGB2ZXJjZWwtYmxvYjogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xuICB9XG59XG5cbi8vIHNyYy9hcGkudHNcbnZhciBCbG9iQWNjZXNzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiQWNjZXNzIGRlbmllZCwgcGxlYXNlIHByb3ZpZGUgYSB2YWxpZCB0b2tlbiBmb3IgdGhpcyByZXNvdXJjZS5cIik7XG4gIH1cbn07XG52YXIgQmxvYlN0b3JlTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGlzIHN0b3JlIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgfVxufTtcbnZhciBCbG9iU3RvcmVTdXNwZW5kZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGlzIHN0b3JlIGhhcyBiZWVuIHN1c3BlbmRlZC5cIik7XG4gIH1cbn07XG52YXIgQmxvYlVua25vd25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJVbmtub3duIGVycm9yLCBwbGVhc2UgdmlzaXQgaHR0cHM6Ly92ZXJjZWwuY29tL2hlbHAuXCIpO1xuICB9XG59O1xudmFyIEJsb2JOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoZSByZXF1ZXN0ZWQgYmxvYiBkb2VzIG5vdCBleGlzdFwiKTtcbiAgfVxufTtcbnZhciBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGUgYmxvYiBzZXJ2aWNlIGlzIGN1cnJlbnRseSBub3QgYXZhaWxhYmxlLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgfVxufTtcbnZhciBCbG9iU2VydmljZVJhdGVMaW1pdGVkID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzZWNvbmRzKSB7XG4gICAgc3VwZXIoXG4gICAgICBgVG9vIG1hbnkgcmVxdWVzdHMgcGxlYXNlIGxvd2VyIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCByZXF1ZXN0cyAke3NlY29uZHMgPyBgIC0gdHJ5IGFnYWluIGluICR7c2Vjb25kc30gc2Vjb25kc2AgOiBcIlwifS5gXG4gICAgKTtcbiAgICB0aGlzLnJldHJ5QWZ0ZXIgPSBzZWNvbmRzICE9IG51bGwgPyBzZWNvbmRzIDogMDtcbiAgfVxufTtcbnZhciBCTE9CX0FQSV9WRVJTSU9OID0gNztcbmZ1bmN0aW9uIGdldEFwaVZlcnNpb24oKSB7XG4gIGxldCB2ZXJzaW9uT3ZlcnJpZGUgPSBudWxsO1xuICB0cnkge1xuICAgIHZlcnNpb25PdmVycmlkZSA9IHByb2Nlc3MuZW52LlZFUkNFTF9CTE9CX0FQSV9WRVJTSU9OX09WRVJSSURFIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX0FQSV9WRVJTSU9OX09WRVJSSURFO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gYCR7dmVyc2lvbk92ZXJyaWRlICE9IG51bGwgPyB2ZXJzaW9uT3ZlcnJpZGUgOiBCTE9CX0FQSV9WRVJTSU9OfWA7XG59XG5mdW5jdGlvbiBnZXRBcGlVcmwocGF0aG5hbWUgPSBcIlwiKSB7XG4gIGxldCBiYXNlVXJsID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBiYXNlVXJsID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfQVBJX1VSTCB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVVJMO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gYCR7YmFzZVVybCB8fCBcImh0dHBzOi8vYmxvYi52ZXJjZWwtc3RvcmFnZS5jb21cIn0ke3BhdGhuYW1lfWA7XG59XG5mdW5jdGlvbiBnZXRSZXRyaWVzKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJldHJpZXMgPSBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9SRVRSSUVTIHx8IFwiMTBcIjtcbiAgICByZXR1cm4gcGFyc2VJbnQocmV0cmllcywgMTApO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gMTA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQocmVzcG9uc2UpIHtcbiAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwicmV0cnktYWZ0ZXJcIik7XG4gIHJldHVybiBuZXcgQmxvYlNlcnZpY2VSYXRlTGltaXRlZChcbiAgICByZXRyeUFmdGVyID8gcGFyc2VJbnQocmV0cnlBZnRlciwgMTApIDogdm9pZCAwXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCbG9iRXJyb3IocmVzcG9uc2UpIHtcbiAgdmFyIF9hMiwgX2IyLCBfYztcbiAgbGV0IGNvZGU7XG4gIGxldCBtZXNzYWdlO1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29kZSA9IChfYjIgPSAoX2EyID0gZGF0YS5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb2RlKSAhPSBudWxsID8gX2IyIDogXCJ1bmtub3duX2Vycm9yXCI7XG4gICAgbWVzc2FnZSA9IChfYyA9IGRhdGEuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYy5tZXNzYWdlO1xuICB9IGNhdGNoIHtcbiAgICBjb2RlID0gXCJ1bmtub3duX2Vycm9yXCI7XG4gIH1cbiAgbGV0IGVycm9yO1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIFwic3RvcmVfc3VzcGVuZGVkXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iU3RvcmVTdXNwZW5kZWRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZvcmJpZGRlblwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkFjY2Vzc0Vycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibm90X2ZvdW5kXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iTm90Rm91bmRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0b3JlX25vdF9mb3VuZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlN0b3JlTm90Rm91bmRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJhZF9yZXF1ZXN0XCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iRXJyb3IobWVzc2FnZSAhPSBudWxsID8gbWVzc2FnZSA6IFwiQmFkIHJlcXVlc3RcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic2VydmljZV91bmF2YWlsYWJsZVwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyYXRlX2xpbWl0ZWRcIjpcbiAgICAgIGVycm9yID0gY3JlYXRlQmxvYlNlcnZpY2VSYXRlTGltaXRlZChyZXNwb25zZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidW5rbm93bl9lcnJvclwiOlxuICAgIGNhc2UgXCJub3RfYWxsb3dlZFwiOlxuICAgIGRlZmF1bHQ6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iVW5rbm93bkVycm9yKCk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4geyBjb2RlLCBlcnJvciB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEFwaShwYXRobmFtZSwgaW5pdCwgY29tbWFuZE9wdGlvbnMpIHtcbiAgY29uc3QgYXBpVmVyc2lvbiA9IGdldEFwaVZlcnNpb24oKTtcbiAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYoY29tbWFuZE9wdGlvbnMpO1xuICBjb25zdCBhcGlSZXNwb25zZSA9IGF3YWl0IHJldHJ5KFxuICAgIGFzeW5jIChiYWlsKSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChnZXRBcGlVcmwocGF0aG5hbWUpLCB7XG4gICAgICAgIC4uLmluaXQsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIngtYXBpLXZlcnNpb25cIjogYXBpVmVyc2lvbixcbiAgICAgICAgICBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAuLi5pbml0LmhlYWRlcnNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGNvZGUsIGVycm9yIH0gPSBhd2FpdCBnZXRCbG9iRXJyb3IocmVzKTtcbiAgICAgIGlmIChjb2RlID09PSBcInVua25vd25fZXJyb3JcIiB8fCBjb2RlID09PSBcInNlcnZpY2VfdW5hdmFpbGFibGVcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGJhaWwoZXJyb3IpO1xuICAgIH0sXG4gICAge1xuICAgICAgcmV0cmllczogZ2V0UmV0cmllcygpLFxuICAgICAgb25SZXRyeTogKGVycm9yKSA9PiB7XG4gICAgICAgIGRlYnVnKGByZXRyeWluZyBBUEkgcmVxdWVzdCB0byAke3BhdGhuYW1lfWAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgaWYgKCFhcGlSZXNwb25zZSkge1xuICAgIHRocm93IG5ldyBCbG9iVW5rbm93bkVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGFwaVJlc3BvbnNlLmpzb24oKTtcbn1cblxuLy8gc3JjL3B1dC1oZWxwZXJzLnRzXG52YXIgcHV0T3B0aW9uSGVhZGVyTWFwID0ge1xuICBjYWNoZUNvbnRyb2xNYXhBZ2U6IFwieC1jYWNoZS1jb250cm9sLW1heC1hZ2VcIixcbiAgYWRkUmFuZG9tU3VmZml4OiBcIngtYWRkLXJhbmRvbS1zdWZmaXhcIixcbiAgY29udGVudFR5cGU6IFwieC1jb250ZW50LXR5cGVcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJjb250ZW50VHlwZVwiKSAmJiBvcHRpb25zLmNvbnRlbnRUeXBlKSB7XG4gICAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuY29udGVudFR5cGVdID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgfVxuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJhZGRSYW5kb21TdWZmaXhcIikgJiYgb3B0aW9ucy5hZGRSYW5kb21TdWZmaXggIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbcHV0T3B0aW9uSGVhZGVyTWFwLmFkZFJhbmRvbVN1ZmZpeF0gPSBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCA/IFwiMVwiIDogXCIwXCI7XG4gIH1cbiAgaWYgKGFsbG93ZWRPcHRpb25zLmluY2x1ZGVzKFwiY2FjaGVDb250cm9sTWF4QWdlXCIpICYmIG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzW3B1dE9wdGlvbkhlYWRlck1hcC5jYWNoZUNvbnRyb2xNYXhBZ2VdID0gb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVB1dE9wdGlvbnMoe1xuICBwYXRobmFtZSxcbiAgb3B0aW9ucyxcbiAgZXh0cmFDaGVja3MsXG4gIGdldFRva2VuXG59KSB7XG4gIGlmICghcGF0aG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwicGF0aG5hbWUgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIm1pc3Npbmcgb3B0aW9ucywgc2VlIHVzYWdlXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLmFjY2VzcyAhPT0gXCJwdWJsaWNcIikge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoJ2FjY2VzcyBtdXN0IGJlIFwicHVibGljXCInKTtcbiAgfVxuICBpZiAoZXh0cmFDaGVja3MpIHtcbiAgICBleHRyYUNoZWNrcyhvcHRpb25zKTtcbiAgfVxuICBpZiAoZ2V0VG9rZW4pIHtcbiAgICBvcHRpb25zLnRva2VuID0gYXdhaXQgZ2V0VG9rZW4ocGF0aG5hbWUsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L2NvbXBsZXRlLnRzXG5mdW5jdGlvbiBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBwYXJ0cywgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gICAgICB1cGxvYWRJZDogb3B0aW9ucy51cGxvYWRJZCxcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBvcHRpb25zLFxuICAgICAgcGFydHNcbiAgICB9KTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkKHtcbiAgdXBsb2FkSWQsXG4gIGtleSxcbiAgcGF0aG5hbWUsXG4gIHBhcnRzLFxuICBoZWFkZXJzLFxuICBvcHRpb25zXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgICAgYC9tcHUvJHtwYXRobmFtZX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICBcIngtbXB1LWFjdGlvblwiOiBcImNvbXBsZXRlXCIsXG4gICAgICAgICAgXCJ4LW1wdS11cGxvYWQtaWRcIjogdXBsb2FkSWQsXG4gICAgICAgICAgLy8ga2V5IGNhbiBiZSBhbnkgdXRmOCBjaGFyYWN0ZXIgc28gd2UgbmVlZCB0byBlbmNvZGUgaXQgYXMgSFRUUCBoZWFkZXJzIGNhbiBvbmx5IGJlIHVzLWFzY2lpXG4gICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzAjc3dlY3Rpb24tMy4yLjRcbiAgICAgICAgICBcIngtbXB1LWtleVwiOiBlbmNvZGVVUkkoa2V5KVxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJ0cylcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBkZWJ1ZyhcIm1wdTogY29tcGxldGVcIiwgcmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgKGVycm9yLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL211bHRpcGFydC9jcmVhdGUudHNcbmZ1bmN0aW9uIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBvcHRpb25zSW5wdXQpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgY3JlYXRlUHV0T3B0aW9ucyh7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWQoXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWRcbiAgICB9O1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKHBhdGhuYW1lLCBoZWFkZXJzLCBvcHRpb25zKSB7XG4gIGRlYnVnKFwibXB1OiBjcmVhdGVcIiwgXCJwYXRobmFtZTpcIiwgcGF0aG5hbWUpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICAgIGAvbXB1LyR7cGF0aG5hbWV9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgXCJ4LW1wdS1hY3Rpb25cIjogXCJjcmVhdGVcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgZGVidWcoXCJtcHU6IGNyZWF0ZVwiLCByZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyb3IubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L3VwbG9hZC50c1xuaW1wb3J0IGJ5dGVzIGZyb20gXCJieXRlc1wiO1xuZnVuY3Rpb24gY3JlYXRlVXBsb2FkUGFydE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBib2R5LCBvcHRpb25zSW5wdXQpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgY3JlYXRlUHV0T3B0aW9ucyh7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICB1cGxvYWRJZDogb3B0aW9ucy51cGxvYWRJZCxcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBwYXRobmFtZSxcbiAgICAgIHBhcnQ6IHsgYmxvYjogYm9keSwgcGFydE51bWJlcjogb3B0aW9ucy5wYXJ0TnVtYmVyIH0sXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGFib3J0Q29udHJvbGxlcjogb3B0aW9ucy5hYm9ydENvbnRyb2xsZXJcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZXRhZzogcmVzdWx0LmV0YWcsXG4gICAgICBwYXJ0TnVtYmVyOiBvcHRpb25zLnBhcnROdW1iZXJcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gdXBsb2FkUGFydCh7XG4gIHVwbG9hZElkLFxuICBrZXksXG4gIHBhdGhuYW1lLFxuICBoZWFkZXJzLFxuICBvcHRpb25zLFxuICBhYm9ydENvbnRyb2xsZXIsXG4gIHBhcnRcbn0pIHtcbiAgcmV0dXJuIHJlcXVlc3RBcGkoXG4gICAgYC9tcHUvJHtwYXRobmFtZX1gLFxuICAgIHtcbiAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgXCJ4LW1wdS1hY3Rpb25cIjogXCJ1cGxvYWRcIixcbiAgICAgICAgXCJ4LW1wdS1rZXlcIjogZW5jb2RlVVJJKGtleSksXG4gICAgICAgIFwieC1tcHUtdXBsb2FkLWlkXCI6IHVwbG9hZElkLFxuICAgICAgICBcIngtbXB1LXBhcnQtbnVtYmVyXCI6IHBhcnQucGFydE51bWJlci50b1N0cmluZygpXG4gICAgICB9LFxuICAgICAgLy8gd2VpcmQgdGhpbmdzIGJldHdlZW4gdW5kaWNpIHR5cGVzIGFuZCBuYXRpdmUgZmV0Y2ggdHlwZXNcbiAgICAgIGJvZHk6IHBhcnQuYmxvYixcbiAgICAgIC8vIHJlcXVpcmVkIGluIG9yZGVyIHRvIHN0cmVhbSBzb21lIGJvZHkgdHlwZXMgdG8gQ2xvdWRmbGFyZVxuICAgICAgLy8gY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIE5vZGUuanMsIHdlIG1heSBoYXZlIHRvIGZlYXR1cmUgZGV0ZWN0IHRoaXNcbiAgICAgIGR1cGxleDogXCJoYWxmXCJcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbnZhciBtYXhDb25jdXJyZW50VXBsb2FkcyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyA2IDogODtcbnZhciBwYXJ0U2l6ZUluQnl0ZXMgPSA4ICogMTAyNCAqIDEwMjQ7XG52YXIgbWF4Qnl0ZXNJbk1lbW9yeSA9IG1heENvbmN1cnJlbnRVcGxvYWRzICogcGFydFNpemVJbkJ5dGVzICogMjtcbmZ1bmN0aW9uIHVwbG9hZEFsbFBhcnRzKHtcbiAgdXBsb2FkSWQsXG4gIGtleSxcbiAgcGF0aG5hbWUsXG4gIHN0cmVhbSxcbiAgaGVhZGVycyxcbiAgb3B0aW9uc1xufSkge1xuICBkZWJ1ZyhcIm1wdTogdXBsb2FkIGluaXRcIiwgXCJrZXk6XCIsIGtleSk7XG4gIGNvbnN0IGludGVybmFsQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHBhcnRzVG9VcGxvYWQgPSBbXTtcbiAgICBjb25zdCBjb21wbGV0ZWRQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgYWN0aXZlVXBsb2FkcyA9IDA7XG4gICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgY3VycmVudFBhcnROdW1iZXIgPSAxO1xuICAgIGxldCByZWplY3RlZCA9IGZhbHNlO1xuICAgIGxldCBjdXJyZW50Qnl0ZXNJbk1lbW9yeSA9IDA7XG4gICAgbGV0IGRvbmVSZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IGJ5dGVzU2VudCA9IDA7XG4gICAgbGV0IGFycmF5QnVmZmVycyA9IFtdO1xuICAgIGxldCBjdXJyZW50UGFydEJ5dGVzUmVhZCA9IDA7XG4gICAgcmVhZCgpLmNhdGNoKGNhbmNlbCk7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgIGRlYnVnKFxuICAgICAgICBcIm1wdTogdXBsb2FkIHJlYWQgc3RhcnRcIixcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzOlwiLFxuICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICBcImN1cnJlbnRCeXRlc0luTWVtb3J5OlwiLFxuICAgICAgICBgJHtieXRlcyhjdXJyZW50Qnl0ZXNJbk1lbW9yeSl9LyR7Ynl0ZXMobWF4Qnl0ZXNJbk1lbW9yeSl9YCxcbiAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgIGJ5dGVzKGJ5dGVzU2VudClcbiAgICAgICk7XG4gICAgICByZWFkaW5nID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChjdXJyZW50Qnl0ZXNJbk1lbW9yeSA8IG1heEJ5dGVzSW5NZW1vcnkgJiYgIXJlamVjdGVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgZG9uZVJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgZGVidWcoXCJtcHU6IHVwbG9hZCByZWFkIGNvbnN1bWVkIHRoZSB3aG9sZSBzdHJlYW1cIik7XG4gICAgICAgICAgICBpZiAoYXJyYXlCdWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcGFydHNUb1VwbG9hZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXJ0TnVtYmVyOiBjdXJyZW50UGFydE51bWJlcisrLFxuICAgICAgICAgICAgICAgIGJsb2I6IG5ldyBCbG9iKGFycmF5QnVmZmVycywge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZW5kUGFydHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudEJ5dGVzSW5NZW1vcnkgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBsZXQgdmFsdWVPZmZzZXQgPSAwO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZU9mZnNldCA8IHZhbHVlLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1BhcnRTaXplID0gcGFydFNpemVJbkJ5dGVzIC0gY3VycmVudFBhcnRCeXRlc1JlYWQ7XG4gICAgICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgdmFsdWVPZmZzZXQgKyByZW1haW5pbmdQYXJ0U2l6ZSxcbiAgICAgICAgICAgICAgdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdmFsdWUuc2xpY2UodmFsdWVPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICBhcnJheUJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgICAgICBjdXJyZW50UGFydEJ5dGVzUmVhZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWVPZmZzZXQgPSBlbmRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcnRCeXRlc1JlYWQgPT09IHBhcnRTaXplSW5CeXRlcykge1xuICAgICAgICAgICAgICBwYXJ0c1RvVXBsb2FkLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhcnROdW1iZXI6IGN1cnJlbnRQYXJ0TnVtYmVyKyssXG4gICAgICAgICAgICAgICAgYmxvYjogbmV3IEJsb2IoYXJyYXlCdWZmZXJzLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFycmF5QnVmZmVycyA9IFtdO1xuICAgICAgICAgICAgICBjdXJyZW50UGFydEJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgICAgIHNlbmRQYXJ0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYW5jZWwoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJtcHU6IHVwbG9hZCByZWFkIGVuZFwiLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHM6XCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgKTtcbiAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2VuZFBhcnQocGFydCkge1xuICAgICAgYWN0aXZlVXBsb2FkcysrO1xuICAgICAgZGVidWcoXG4gICAgICAgIFwibXB1OiB1cGxvYWQgc2VuZCBwYXJ0IHN0YXJ0XCIsXG4gICAgICAgIFwicGFydE51bWJlcjpcIixcbiAgICAgICAgcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICBcInNpemU6XCIsXG4gICAgICAgIHBhcnQuYmxvYi5zaXplLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHM6XCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRlZFBhcnQgPSBhd2FpdCB1cGxvYWRQYXJ0KHtcbiAgICAgICAgICB1cGxvYWRJZCxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGFib3J0Q29udHJvbGxlcjogaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIsXG4gICAgICAgICAgcGFydFxuICAgICAgICB9KTtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgXCJtcHU6IHVwbG9hZCBzZW5kIHBhcnQgZW5kXCIsXG4gICAgICAgICAgXCJwYXJ0TnVtYmVyOlwiLFxuICAgICAgICAgIHBhcnQucGFydE51bWJlcixcbiAgICAgICAgICBcImFjdGl2ZVVwbG9hZHNcIixcbiAgICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgICAgYCR7Ynl0ZXMoY3VycmVudEJ5dGVzSW5NZW1vcnkpfS8ke2J5dGVzKG1heEJ5dGVzSW5NZW1vcnkpfWAsXG4gICAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgICApO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29tcGxldGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgcGFydE51bWJlcjogcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICAgIGV0YWc6IGNvbXBsZXRlZFBhcnQuZXRhZ1xuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudEJ5dGVzSW5NZW1vcnkgLT0gcGFydC5ibG9iLnNpemU7XG4gICAgICAgIGFjdGl2ZVVwbG9hZHMtLTtcbiAgICAgICAgYnl0ZXNTZW50ICs9IHBhcnQuYmxvYi5zaXplO1xuICAgICAgICBpZiAocGFydHNUb1VwbG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2VuZFBhcnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbmVSZWFkaW5nKSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZVVwbG9hZHMgPT09IDApIHtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgcmVzb2x2ZShjb21wbGV0ZWRQYXJ0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlYWRpbmcpIHtcbiAgICAgICAgICByZWFkKCkuY2F0Y2goY2FuY2VsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FuY2VsKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2VuZFBhcnRzKCkge1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlYnVnKFxuICAgICAgICBcInNlbmQgcGFydHNcIixcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzXCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwicGFydHNUb1VwbG9hZFwiLFxuICAgICAgICBwYXJ0c1RvVXBsb2FkLmxlbmd0aFxuICAgICAgKTtcbiAgICAgIHdoaWxlIChhY3RpdmVVcGxvYWRzIDwgbWF4Q29uY3VycmVudFVwbG9hZHMgJiYgcGFydHNUb1VwbG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcnRUb1NlbmQgPSBwYXJ0c1RvVXBsb2FkLnNoaWZ0KCk7XG4gICAgICAgIGlmIChwYXJ0VG9TZW5kKSB7XG4gICAgICAgICAgdm9pZCBzZW5kUGFydChwYXJ0VG9TZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWwoZXJyb3IpIHtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICBpbnRlcm5hbEFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgKGVycm9yLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL211bHRpcGFydC9oZWxwZXJzLnRzXG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gXCJzdHJlYW1cIjtcbmltcG9ydCBpc0J1ZmZlciBmcm9tIFwiaXMtYnVmZmVyXCI7XG5mdW5jdGlvbiB0b1JlYWRhYmxlU3RyZWFtKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gdmFsdWUuc3RyZWFtKCk7XG4gIH1cbiAgaWYgKGlzTm9kZUpzUmVhZGFibGVTdHJlYW0odmFsdWUpKSB7XG4gICAgcmV0dXJuIFJlYWRhYmxlLnRvV2ViKHZhbHVlKTtcbiAgfVxuICBsZXQgc3RyZWFtVmFsdWU7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgc3RyZWFtVmFsdWUgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc05vZGVKc0J1ZmZlck9yU3RyaW5nKHZhbHVlKSkge1xuICAgIHN0cmVhbVZhbHVlID0gdmFsdWUuYnVmZmVyO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbVZhbHVlID0gc3RyaW5nVG9VaW50OEFycmF5KHZhbHVlKTtcbiAgfVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoc3RyZWFtVmFsdWUpO1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc05vZGVKc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnBpcGUgPT09IFwiZnVuY3Rpb25cIiAmJiB2YWx1ZS5yZWFkYWJsZSAmJiB0eXBlb2YgdmFsdWUuX3JlYWQgPT09IFwiZnVuY3Rpb25cIiAmJiAvLyBAdHMtZXhwZWN0LWVycm9yIF9yZWFkYWJsZVN0YXRlIGRvZXMgZXhpc3RzIG9uIFJlYWRhYmxlXG4gIHR5cGVvZiB2YWx1ZS5fcmVhZGFibGVTdGF0ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvVWludDhBcnJheShzKSB7XG4gIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICByZXR1cm4gZW5jLmVuY29kZShzKTtcbn1cbmZ1bmN0aW9uIGlzTm9kZUpzQnVmZmVyT3JTdHJpbmcoaW5wdXQpIHtcbiAgcmV0dXJuIGlzQnVmZmVyKGlucHV0KTtcbn1cblxuLy8gc3JjL211bHRpcGFydC91bmNvbnRyb2xsZWQudHNcbmFzeW5jIGZ1bmN0aW9uIHVuY29udHJvbGxlZE11bHRpcGFydFVwbG9hZChwYXRobmFtZSwgYm9keSwgaGVhZGVycywgb3B0aW9ucykge1xuICBkZWJ1ZyhcIm1wdTogaW5pdFwiLCBcInBhdGhuYW1lOlwiLCBwYXRobmFtZSwgXCJoZWFkZXJzOlwiLCBoZWFkZXJzKTtcbiAgY29uc3Qgc3RyZWFtID0gdG9SZWFkYWJsZVN0cmVhbShib2R5KTtcbiAgY29uc3QgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWQoXG4gICAgcGF0aG5hbWUsXG4gICAgaGVhZGVycyxcbiAgICBvcHRpb25zXG4gICk7XG4gIGNvbnN0IHBhcnRzID0gYXdhaXQgdXBsb2FkQWxsUGFydHMoe1xuICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICBwYXRobmFtZSxcbiAgICBzdHJlYW0sXG4gICAgaGVhZGVycyxcbiAgICBvcHRpb25zXG4gIH0pO1xuICBjb25zdCBibG9iID0gYXdhaXQgY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoe1xuICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJ0cyxcbiAgICBoZWFkZXJzLFxuICAgIG9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiBibG9iO1xufVxuXG4vLyBzcmMvcHV0LnRzXG5mdW5jdGlvbiBjcmVhdGVQdXRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9ucyxcbiAgZ2V0VG9rZW4sXG4gIGV4dHJhQ2hlY2tzXG59KSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBwdXQocGF0aG5hbWUsIGJvZHlPck9wdGlvbnMsIG9wdGlvbnNJbnB1dCkge1xuICAgIGNvbnN0IGlzRm9sZGVyQ3JlYXRpb24gPSBwYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gICAgaWYgKCFib2R5T3JPcHRpb25zICYmICFpc0ZvbGRlckNyZWF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiYm9keSBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKGJvZHlPck9wdGlvbnMgJiYgb3B0aW9uc0lucHV0ICYmIGlzRm9sZGVyQ3JlYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJib2R5IGlzIG5vdCBhbGxvd2VkIGZvciBjcmVhdGluZyBlbXB0eSBmb2xkZXJzXCIpO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gaXNGb2xkZXJDcmVhdGlvbiA/IHZvaWQgMCA6IGJvZHlPck9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICAvLyB3aGVuIG5vIGJvZHkgaXMgcmVxdWlyZWQgKGZvciBmb2xkZXIgY3JlYXRpb25zKSBvcHRpb25zIGFyZSB0aGUgc2Vjb25kIGFyZ3VtZW50XG4gICAgICBvcHRpb25zOiBpc0ZvbGRlckNyZWF0aW9uID8gYm9keU9yT3B0aW9ucyA6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMubXVsdGlwYXJ0ID09PSB0cnVlICYmIGJvZHkpIHtcbiAgICAgIHJldHVybiB1bmNvbnRyb2xsZWRNdWx0aXBhcnRVcGxvYWQocGF0aG5hbWUsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgICBgLyR7cGF0aG5hbWV9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBib2R5LFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICAvLyByZXF1aXJlZCBpbiBvcmRlciB0byBzdHJlYW0gc29tZSBib2R5IHR5cGVzIHRvIENsb3VkZmxhcmVcbiAgICAgICAgLy8gY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIE5vZGUuanMsIHdlIG1heSBoYXZlIHRvIGZlYXR1cmUgZGV0ZWN0IHRoaXNcbiAgICAgICAgZHVwbGV4OiBcImhhbGZcIlxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgIGRvd25sb2FkVXJsOiByZXNwb25zZS5kb3dubG9hZFVybCxcbiAgICAgIHBhdGhuYW1lOiByZXNwb25zZS5wYXRobmFtZSxcbiAgICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5jb250ZW50VHlwZSxcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogcmVzcG9uc2UuY29udGVudERpc3Bvc2l0aW9uXG4gICAgfTtcbiAgfTtcbn1cblxuLy8gc3JjL211bHRpcGFydC9jcmVhdGUtdXBsb2FkZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZGVyTWV0aG9kKHsgYWxsb3dlZE9wdGlvbnMsIGdldFRva2VuLCBleHRyYUNoZWNrcyB9KSB7XG4gIHJldHVybiBhc3luYyAocGF0aG5hbWUsIG9wdGlvbnNJbnB1dCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZU11bHRpcGFydFVwbG9hZChcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICAgIGFzeW5jIHVwbG9hZFBhcnQocGFydE51bWJlciwgYm9keSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGxvYWRQYXJ0KHtcbiAgICAgICAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWQsXG4gICAgICAgICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgcGFydDogeyBwYXJ0TnVtYmVyLCBibG9iOiBib2R5IH0sXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV0YWc6IHJlc3VsdC5ldGFnLFxuICAgICAgICAgIHBhcnROdW1iZXJcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBjb21wbGV0ZShwYXJ0cykge1xuICAgICAgICByZXR1cm4gY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoe1xuICAgICAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICAgICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IHtcbiAgZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52LFxuICBCbG9iRXJyb3IsXG4gIGdldERvd25sb2FkVXJsLFxuICBCbG9iQWNjZXNzRXJyb3IsXG4gIEJsb2JTdG9yZU5vdEZvdW5kRXJyb3IsXG4gIEJsb2JTdG9yZVN1c3BlbmRlZEVycm9yLFxuICBCbG9iVW5rbm93bkVycm9yLFxuICBCbG9iTm90Rm91bmRFcnJvcixcbiAgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUsXG4gIHJlcXVlc3RBcGksXG4gIGNyZWF0ZUNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kLFxuICBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZVVwbG9hZFBhcnRNZXRob2QsXG4gIGNyZWF0ZVB1dE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1JREtDWTRTMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/chunk-IDKCY4S2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/client.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/client.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   completeMultipartUpload: () => (/* binding */ completeMultipartUpload),\n/* harmony export */   createMultipartUpload: () => (/* binding */ createMultipartUpload),\n/* harmony export */   createMultipartUploader: () => (/* binding */ createMultipartUploader),\n/* harmony export */   generateClientTokenFromReadWriteToken: () => (/* binding */ generateClientTokenFromReadWriteToken),\n/* harmony export */   getPayloadFromClientToken: () => (/* binding */ getPayloadFromClientToken),\n/* harmony export */   handleUpload: () => (/* binding */ handleUpload),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   upload: () => (/* binding */ upload),\n/* harmony export */   uploadPart: () => (/* binding */ uploadPart)\n/* harmony export */ });\n/* harmony import */ var _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-IDKCY4S2.js */ \"(rsc)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/chunk-IDKCY4S2.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! undici */ \"(rsc)/./node_modules/.pnpm/undici@5.29.0/node_modules/undici/index.js\");\n\n\n// src/client.ts\n\n\nfunction createPutExtraChecks(methodName) {\n  return function extraChecks(options) {\n    if (typeof window === \"undefined\") {\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        `${methodName} must be called from a client environment`\n      );\n    }\n    if (!options.token.startsWith(\"vercel_blob_client_\")) {\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(`${methodName} must be called with a client token`);\n    }\n    if (\n      // @ts-expect-error -- Runtime check for DX.\n      options.addRandomSuffix !== void 0 || // @ts-expect-error -- Runtime check for DX.\n      options.cacheControlMaxAge !== void 0\n    ) {\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        `${methodName} doesn't allow addRandomSuffix and cacheControlMaxAge. Configure these options at the server side when generating client tokens.`\n      );\n    }\n  };\n}\nvar put = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.createPutMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks: createPutExtraChecks(\"client/`put`\")\n});\nvar createMultipartUpload = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.createCreateMultipartUploadMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks: createPutExtraChecks(\"client/`createMultipartUpload`\")\n});\nvar createMultipartUploader = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.createCreateMultipartUploaderMethod)(\n  {\n    allowedOptions: [\"contentType\"],\n    extraChecks: createPutExtraChecks(\"client/`createMultipartUpload`\")\n  }\n);\nvar uploadPart = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.createUploadPartMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks: createPutExtraChecks(\"client/`multipartUpload`\")\n});\nvar completeMultipartUpload = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.createCompleteMultipartUploadMethod)(\n  {\n    allowedOptions: [\"contentType\"],\n    extraChecks: createPutExtraChecks(\"client/`completeMultipartUpload`\")\n  }\n);\nvar upload = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.createPutMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks(options) {\n    if (typeof window === \"undefined\") {\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        \"client/`upload` must be called from a client environment\"\n      );\n    }\n    if (options.handleUploadUrl === void 0) {\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        \"client/`upload` requires the 'handleUploadUrl' parameter\"\n      );\n    }\n    if (\n      // @ts-expect-error -- Runtime check for DX.\n      options.addRandomSuffix !== void 0 || // @ts-expect-error -- Runtime check for DX.\n      options.cacheControlMaxAge !== void 0\n    ) {\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        \"client/`upload` doesn't allow addRandomSuffix and cacheControlMaxAge. Configure these options at the server side when generating client tokens.\"\n      );\n    }\n  },\n  async getToken(pathname, options) {\n    var _a, _b;\n    return retrieveClientToken({\n      handleUploadUrl: options.handleUploadUrl,\n      pathname,\n      clientPayload: (_a = options.clientPayload) != null ? _a : null,\n      multipart: (_b = options.multipart) != null ? _b : false\n    });\n  }\n});\nasync function importKey(token) {\n  return globalThis.crypto.subtle.importKey(\n    \"raw\",\n    new TextEncoder().encode(token),\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false,\n    [\"sign\", \"verify\"]\n  );\n}\nasync function signPayload(payload, token) {\n  if (!globalThis.crypto) {\n    return crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac(\"sha256\", token).update(payload).digest(\"hex\");\n  }\n  const signature = await globalThis.crypto.subtle.sign(\n    \"HMAC\",\n    await importKey(token),\n    new TextEncoder().encode(payload)\n  );\n  return Buffer.from(new Uint8Array(signature)).toString(\"hex\");\n}\nasync function verifyCallbackSignature({\n  token,\n  signature,\n  body\n}) {\n  const secret = token;\n  if (!globalThis.crypto) {\n    const digest = crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac(\"sha256\", secret).update(body).digest(\"hex\");\n    const digestBuffer = Buffer.from(digest);\n    const signatureBuffer = Buffer.from(signature);\n    return digestBuffer.length === signatureBuffer.length && crypto__WEBPACK_IMPORTED_MODULE_0__.timingSafeEqual(digestBuffer, signatureBuffer);\n  }\n  const verified = await globalThis.crypto.subtle.verify(\n    \"HMAC\",\n    await importKey(token),\n    hexToArrayByte(signature),\n    new TextEncoder().encode(body)\n  );\n  return verified;\n}\nfunction hexToArrayByte(input) {\n  if (input.length % 2 !== 0) {\n    throw new RangeError(\"Expected string to be an even number of characters\");\n  }\n  const view = new Uint8Array(input.length / 2);\n  for (let i = 0; i < input.length; i += 2) {\n    view[i / 2] = parseInt(input.substring(i, i + 2), 16);\n  }\n  return Buffer.from(view);\n}\nfunction getPayloadFromClientToken(clientToken) {\n  const [, , , , encodedToken] = clientToken.split(\"_\");\n  const encodedPayload = Buffer.from(encodedToken != null ? encodedToken : \"\", \"base64\").toString().split(\".\")[1];\n  const decodedPayload = Buffer.from(encodedPayload != null ? encodedPayload : \"\", \"base64\").toString();\n  return JSON.parse(decodedPayload);\n}\nvar EventTypes = {\n  generateClientToken: \"blob.generate-client-token\",\n  uploadCompleted: \"blob.upload-completed\"\n};\nasync function handleUpload({\n  token,\n  request,\n  body,\n  onBeforeGenerateToken,\n  onUploadCompleted\n}) {\n  var _a, _b, _c, _d;\n  const resolvedToken = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.getTokenFromOptionsOrEnv)({ token });\n  const type = body.type;\n  switch (type) {\n    case \"blob.generate-client-token\": {\n      const { pathname, callbackUrl, clientPayload, multipart } = body.payload;\n      const payload = await onBeforeGenerateToken(\n        pathname,\n        clientPayload,\n        multipart\n      );\n      const tokenPayload = (_a = payload.tokenPayload) != null ? _a : clientPayload;\n      const oneHourInSeconds = 60 * 60;\n      const now = /* @__PURE__ */ new Date();\n      const validUntil = (_b = payload.validUntil) != null ? _b : now.setSeconds(now.getSeconds() + oneHourInSeconds);\n      return {\n        type,\n        clientToken: await generateClientTokenFromReadWriteToken({\n          ...payload,\n          token: resolvedToken,\n          pathname,\n          onUploadCompleted: {\n            callbackUrl,\n            tokenPayload\n          },\n          validUntil\n        })\n      };\n    }\n    case \"blob.upload-completed\": {\n      const signatureHeader = \"x-vercel-signature\";\n      const signature = \"credentials\" in request ? (_c = request.headers.get(signatureHeader)) != null ? _c : \"\" : (_d = request.headers[signatureHeader]) != null ? _d : \"\";\n      if (!signature) {\n        throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Missing callback signature\");\n      }\n      const isVerified = await verifyCallbackSignature({\n        token: resolvedToken,\n        signature,\n        body: JSON.stringify(body)\n      });\n      if (!isVerified) {\n        throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Invalid callback signature\");\n      }\n      await onUploadCompleted(body.payload);\n      return { type, response: \"ok\" };\n    }\n    default:\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Invalid event type\");\n  }\n}\nasync function retrieveClientToken(options) {\n  const { handleUploadUrl, pathname } = options;\n  const url = isAbsoluteUrl(handleUploadUrl) ? handleUploadUrl : toAbsoluteUrl(handleUploadUrl);\n  const event = {\n    type: EventTypes.generateClientToken,\n    payload: {\n      pathname,\n      callbackUrl: url,\n      clientPayload: options.clientPayload,\n      multipart: options.multipart\n    }\n  };\n  const res = await (0,undici__WEBPACK_IMPORTED_MODULE_1__.fetch)(url, {\n    method: \"POST\",\n    body: JSON.stringify(event),\n    headers: {\n      \"content-type\": \"application/json\"\n    }\n  });\n  if (!res.ok) {\n    throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Failed to  retrieve the client token\");\n  }\n  try {\n    const { clientToken } = await res.json();\n    return clientToken;\n  } catch (e) {\n    throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Failed to retrieve the client token\");\n  }\n}\nfunction toAbsoluteUrl(url) {\n  return new URL(url, window.location.href).href;\n}\nfunction isAbsoluteUrl(url) {\n  try {\n    return Boolean(new URL(url));\n  } catch (e) {\n    return false;\n  }\n}\nasync function generateClientTokenFromReadWriteToken({\n  token,\n  ...argsWithoutToken\n}) {\n  var _a;\n  if (typeof window !== \"undefined\") {\n    throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n      '\"generateClientTokenFromReadWriteToken\" must be called from a server environment'\n    );\n  }\n  const timestamp = /* @__PURE__ */ new Date();\n  timestamp.setSeconds(timestamp.getSeconds() + 30);\n  const readWriteToken = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.getTokenFromOptionsOrEnv)({ token });\n  const [, , , storeId = null] = readWriteToken.split(\"_\");\n  if (!storeId) {\n    throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n      token ? \"Invalid `token` parameter\" : \"Invalid `BLOB_READ_WRITE_TOKEN`\"\n    );\n  }\n  const payload = Buffer.from(\n    JSON.stringify({\n      ...argsWithoutToken,\n      validUntil: (_a = argsWithoutToken.validUntil) != null ? _a : timestamp.getTime()\n    })\n  ).toString(\"base64\");\n  const securedKey = await signPayload(payload, readWriteToken);\n  if (!securedKey) {\n    throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Unable to sign client token\");\n  }\n  return `vercel_blob_client_${storeId}_${Buffer.from(\n    `${securedKey}.${payload}`\n  ).toString(\"base64\")}`;\n}\n\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZlcmNlbCtibG9iQDAuMjIuMy9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQVE2Qjs7QUFFN0I7QUFDaUM7QUFDRjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVM7QUFDekIsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBUyxJQUFJLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUVBQWU7QUFDekI7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEIscUZBQWlDO0FBQzdEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCLHVGQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBFQUFzQjtBQUN2QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4Qix1RkFBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwrQkFBK0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxtQkFBbUIsOENBQWlCO0FBQ3BDO0FBQ0E7QUFDQSw2REFBNkQsbURBQXNCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3QkFBd0IsNEVBQXdCLEdBQUcsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFrRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlEQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0IseURBQVM7QUFDM0I7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLHlEQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQSxJQUFJO0FBQ0osY0FBYyx5REFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsY0FBYyx5REFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRFQUF3QixHQUFHLE9BQU87QUFDM0Q7QUFDQTtBQUNBLGNBQWMseURBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBUztBQUN2QjtBQUNBLCtCQUErQixRQUFRLEdBQUc7QUFDMUMsT0FBTyxXQUFXLEdBQUcsUUFBUTtBQUM3Qix1QkFBdUI7QUFDdkI7QUFXRTtBQUNGIiwic291cmNlcyI6WyJDOlxccHJvamVjdHNcXGF1dGhcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEB2ZXJjZWwrYmxvYkAwLjIyLjNcXG5vZGVfbW9kdWxlc1xcQHZlcmNlbFxcYmxvYlxcZGlzdFxcY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJsb2JFcnJvcixcbiAgY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QsXG4gIGNyZWF0ZVB1dE1ldGhvZCxcbiAgY3JlYXRlVXBsb2FkUGFydE1ldGhvZCxcbiAgZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52XG59IGZyb20gXCIuL2NodW5rLUlES0NZNFMyLmpzXCI7XG5cbi8vIHNyYy9jbGllbnQudHNcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5pbXBvcnQgeyBmZXRjaCB9IGZyb20gXCJ1bmRpY2lcIjtcbmZ1bmN0aW9uIGNyZWF0ZVB1dEV4dHJhQ2hlY2tzKG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGV4dHJhQ2hlY2tzKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgYCR7bWV0aG9kTmFtZX0gbXVzdCBiZSBjYWxsZWQgZnJvbSBhIGNsaWVudCBlbnZpcm9ubWVudGBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy50b2tlbi5zdGFydHNXaXRoKFwidmVyY2VsX2Jsb2JfY2xpZW50X1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihgJHttZXRob2ROYW1lfSBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgY2xpZW50IHRva2VuYCk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUnVudGltZSBjaGVjayBmb3IgRFguXG4gICAgICBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCAhPT0gdm9pZCAwIHx8IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUnVudGltZSBjaGVjayBmb3IgRFguXG4gICAgICBvcHRpb25zLmNhY2hlQ29udHJvbE1heEFnZSAhPT0gdm9pZCAwXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBgJHttZXRob2ROYW1lfSBkb2Vzbid0IGFsbG93IGFkZFJhbmRvbVN1ZmZpeCBhbmQgY2FjaGVDb250cm9sTWF4QWdlLiBDb25maWd1cmUgdGhlc2Ugb3B0aW9ucyBhdCB0aGUgc2VydmVyIHNpZGUgd2hlbiBnZW5lcmF0aW5nIGNsaWVudCB0b2tlbnMuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG52YXIgcHV0ID0gY3JlYXRlUHV0TWV0aG9kKHtcbiAgYWxsb3dlZE9wdGlvbnM6IFtcImNvbnRlbnRUeXBlXCJdLFxuICBleHRyYUNoZWNrczogY3JlYXRlUHV0RXh0cmFDaGVja3MoXCJjbGllbnQvYHB1dGBcIilcbn0pO1xudmFyIGNyZWF0ZU11bHRpcGFydFVwbG9hZCA9IGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjb250ZW50VHlwZVwiXSxcbiAgZXh0cmFDaGVja3M6IGNyZWF0ZVB1dEV4dHJhQ2hlY2tzKFwiY2xpZW50L2BjcmVhdGVNdWx0aXBhcnRVcGxvYWRgXCIpXG59KTtcbnZhciBjcmVhdGVNdWx0aXBhcnRVcGxvYWRlciA9IGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZGVyTWV0aG9kKFxuICB7XG4gICAgYWxsb3dlZE9wdGlvbnM6IFtcImNvbnRlbnRUeXBlXCJdLFxuICAgIGV4dHJhQ2hlY2tzOiBjcmVhdGVQdXRFeHRyYUNoZWNrcyhcImNsaWVudC9gY3JlYXRlTXVsdGlwYXJ0VXBsb2FkYFwiKVxuICB9XG4pO1xudmFyIHVwbG9hZFBhcnQgPSBjcmVhdGVVcGxvYWRQYXJ0TWV0aG9kKHtcbiAgYWxsb3dlZE9wdGlvbnM6IFtcImNvbnRlbnRUeXBlXCJdLFxuICBleHRyYUNoZWNrczogY3JlYXRlUHV0RXh0cmFDaGVja3MoXCJjbGllbnQvYG11bHRpcGFydFVwbG9hZGBcIilcbn0pO1xudmFyIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkID0gY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QoXG4gIHtcbiAgICBhbGxvd2VkT3B0aW9uczogW1wiY29udGVudFR5cGVcIl0sXG4gICAgZXh0cmFDaGVja3M6IGNyZWF0ZVB1dEV4dHJhQ2hlY2tzKFwiY2xpZW50L2Bjb21wbGV0ZU11bHRpcGFydFVwbG9hZGBcIilcbiAgfVxuKTtcbnZhciB1cGxvYWQgPSBjcmVhdGVQdXRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY29udGVudFR5cGVcIl0sXG4gIGV4dHJhQ2hlY2tzKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgXCJjbGllbnQvYHVwbG9hZGAgbXVzdCBiZSBjYWxsZWQgZnJvbSBhIGNsaWVudCBlbnZpcm9ubWVudFwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVVcGxvYWRVcmwgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgXCJjbGllbnQvYHVwbG9hZGAgcmVxdWlyZXMgdGhlICdoYW5kbGVVcGxvYWRVcmwnIHBhcmFtZXRlclwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFJ1bnRpbWUgY2hlY2sgZm9yIERYLlxuICAgICAgb3B0aW9ucy5hZGRSYW5kb21TdWZmaXggIT09IHZvaWQgMCB8fCAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFJ1bnRpbWUgY2hlY2sgZm9yIERYLlxuICAgICAgb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UgIT09IHZvaWQgMFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgXCJjbGllbnQvYHVwbG9hZGAgZG9lc24ndCBhbGxvdyBhZGRSYW5kb21TdWZmaXggYW5kIGNhY2hlQ29udHJvbE1heEFnZS4gQ29uZmlndXJlIHRoZXNlIG9wdGlvbnMgYXQgdGhlIHNlcnZlciBzaWRlIHdoZW4gZ2VuZXJhdGluZyBjbGllbnQgdG9rZW5zLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAgYXN5bmMgZ2V0VG9rZW4ocGF0aG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiByZXRyaWV2ZUNsaWVudFRva2VuKHtcbiAgICAgIGhhbmRsZVVwbG9hZFVybDogb3B0aW9ucy5oYW5kbGVVcGxvYWRVcmwsXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGNsaWVudFBheWxvYWQ6IChfYSA9IG9wdGlvbnMuY2xpZW50UGF5bG9hZCkgIT0gbnVsbCA/IF9hIDogbnVsbCxcbiAgICAgIG11bHRpcGFydDogKF9iID0gb3B0aW9ucy5tdWx0aXBhcnQpICE9IG51bGwgPyBfYiA6IGZhbHNlXG4gICAgfSk7XG4gIH1cbn0pO1xuYXN5bmMgZnVuY3Rpb24gaW1wb3J0S2V5KHRva2VuKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgIFwicmF3XCIsXG4gICAgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRva2VuKSxcbiAgICB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBcIlNIQS0yNTZcIiB9LFxuICAgIGZhbHNlLFxuICAgIFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl1cbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25QYXlsb2FkKHBheWxvYWQsIHRva2VuKSB7XG4gIGlmICghZ2xvYmFsVGhpcy5jcnlwdG8pIHtcbiAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgdG9rZW4pLnVwZGF0ZShwYXlsb2FkKS5kaWdlc3QoXCJoZXhcIik7XG4gIH1cbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlLnNpZ24oXG4gICAgXCJITUFDXCIsXG4gICAgYXdhaXQgaW1wb3J0S2V5KHRva2VuKSxcbiAgICBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGF5bG9hZClcbiAgKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkpLnRvU3RyaW5nKFwiaGV4XCIpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5Q2FsbGJhY2tTaWduYXR1cmUoe1xuICB0b2tlbixcbiAgc2lnbmF0dXJlLFxuICBib2R5XG59KSB7XG4gIGNvbnN0IHNlY3JldCA9IHRva2VuO1xuICBpZiAoIWdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgY29uc3QgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgc2VjcmV0KS51cGRhdGUoYm9keSkuZGlnZXN0KFwiaGV4XCIpO1xuICAgIGNvbnN0IGRpZ2VzdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRpZ2VzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gZGlnZXN0QnVmZmVyLmxlbmd0aCA9PT0gc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCAmJiBjcnlwdG8udGltaW5nU2FmZUVxdWFsKGRpZ2VzdEJ1ZmZlciwgc2lnbmF0dXJlQnVmZmVyKTtcbiAgfVxuICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS52ZXJpZnkoXG4gICAgXCJITUFDXCIsXG4gICAgYXdhaXQgaW1wb3J0S2V5KHRva2VuKSxcbiAgICBoZXhUb0FycmF5Qnl0ZShzaWduYXR1cmUpLFxuICAgIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShib2R5KVxuICApO1xuICByZXR1cm4gdmVyaWZpZWQ7XG59XG5mdW5jdGlvbiBoZXhUb0FycmF5Qnl0ZShpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIHRvIGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGNoYXJhY3RlcnNcIik7XG4gIH1cbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCAvIDIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmlld1tpIC8gMl0gPSBwYXJzZUludChpbnB1dC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNik7XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZpZXcpO1xufVxuZnVuY3Rpb24gZ2V0UGF5bG9hZEZyb21DbGllbnRUb2tlbihjbGllbnRUb2tlbikge1xuICBjb25zdCBbLCAsICwgLCBlbmNvZGVkVG9rZW5dID0gY2xpZW50VG9rZW4uc3BsaXQoXCJfXCIpO1xuICBjb25zdCBlbmNvZGVkUGF5bG9hZCA9IEJ1ZmZlci5mcm9tKGVuY29kZWRUb2tlbiAhPSBudWxsID8gZW5jb2RlZFRva2VuIDogXCJcIiwgXCJiYXNlNjRcIikudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV07XG4gIGNvbnN0IGRlY29kZWRQYXlsb2FkID0gQnVmZmVyLmZyb20oZW5jb2RlZFBheWxvYWQgIT0gbnVsbCA/IGVuY29kZWRQYXlsb2FkIDogXCJcIiwgXCJiYXNlNjRcIikudG9TdHJpbmcoKTtcbiAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZFBheWxvYWQpO1xufVxudmFyIEV2ZW50VHlwZXMgPSB7XG4gIGdlbmVyYXRlQ2xpZW50VG9rZW46IFwiYmxvYi5nZW5lcmF0ZS1jbGllbnQtdG9rZW5cIixcbiAgdXBsb2FkQ29tcGxldGVkOiBcImJsb2IudXBsb2FkLWNvbXBsZXRlZFwiXG59O1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlVXBsb2FkKHtcbiAgdG9rZW4sXG4gIHJlcXVlc3QsXG4gIGJvZHksXG4gIG9uQmVmb3JlR2VuZXJhdGVUb2tlbixcbiAgb25VcGxvYWRDb21wbGV0ZWRcbn0pIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICBjb25zdCByZXNvbHZlZFRva2VuID0gZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52KHsgdG9rZW4gfSk7XG4gIGNvbnN0IHR5cGUgPSBib2R5LnR5cGU7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJibG9iLmdlbmVyYXRlLWNsaWVudC10b2tlblwiOiB7XG4gICAgICBjb25zdCB7IHBhdGhuYW1lLCBjYWxsYmFja1VybCwgY2xpZW50UGF5bG9hZCwgbXVsdGlwYXJ0IH0gPSBib2R5LnBheWxvYWQ7XG4gICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgb25CZWZvcmVHZW5lcmF0ZVRva2VuKFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgY2xpZW50UGF5bG9hZCxcbiAgICAgICAgbXVsdGlwYXJ0XG4gICAgICApO1xuICAgICAgY29uc3QgdG9rZW5QYXlsb2FkID0gKF9hID0gcGF5bG9hZC50b2tlblBheWxvYWQpICE9IG51bGwgPyBfYSA6IGNsaWVudFBheWxvYWQ7XG4gICAgICBjb25zdCBvbmVIb3VySW5TZWNvbmRzID0gNjAgKiA2MDtcbiAgICAgIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgdmFsaWRVbnRpbCA9IChfYiA9IHBheWxvYWQudmFsaWRVbnRpbCkgIT0gbnVsbCA/IF9iIDogbm93LnNldFNlY29uZHMobm93LmdldFNlY29uZHMoKSArIG9uZUhvdXJJblNlY29uZHMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2xpZW50VG9rZW46IGF3YWl0IGdlbmVyYXRlQ2xpZW50VG9rZW5Gcm9tUmVhZFdyaXRlVG9rZW4oe1xuICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgdG9rZW46IHJlc29sdmVkVG9rZW4sXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgb25VcGxvYWRDb21wbGV0ZWQ6IHtcbiAgICAgICAgICAgIGNhbGxiYWNrVXJsLFxuICAgICAgICAgICAgdG9rZW5QYXlsb2FkXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2YWxpZFVudGlsXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiYmxvYi51cGxvYWQtY29tcGxldGVkXCI6IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUhlYWRlciA9IFwieC12ZXJjZWwtc2lnbmF0dXJlXCI7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBcImNyZWRlbnRpYWxzXCIgaW4gcmVxdWVzdCA/IChfYyA9IHJlcXVlc3QuaGVhZGVycy5nZXQoc2lnbmF0dXJlSGVhZGVyKSkgIT0gbnVsbCA/IF9jIDogXCJcIiA6IChfZCA9IHJlcXVlc3QuaGVhZGVyc1tzaWduYXR1cmVIZWFkZXJdKSAhPSBudWxsID8gX2QgOiBcIlwiO1xuICAgICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIk1pc3NpbmcgY2FsbGJhY2sgc2lnbmF0dXJlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IHZlcmlmeUNhbGxiYWNrU2lnbmF0dXJlKHtcbiAgICAgICAgdG9rZW46IHJlc29sdmVkVG9rZW4sXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc1ZlcmlmaWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJJbnZhbGlkIGNhbGxiYWNrIHNpZ25hdHVyZVwiKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG9uVXBsb2FkQ29tcGxldGVkKGJvZHkucGF5bG9hZCk7XG4gICAgICByZXR1cm4geyB0eXBlLCByZXNwb25zZTogXCJva1wiIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiSW52YWxpZCBldmVudCB0eXBlXCIpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZXRyaWV2ZUNsaWVudFRva2VuKG9wdGlvbnMpIHtcbiAgY29uc3QgeyBoYW5kbGVVcGxvYWRVcmwsIHBhdGhuYW1lIH0gPSBvcHRpb25zO1xuICBjb25zdCB1cmwgPSBpc0Fic29sdXRlVXJsKGhhbmRsZVVwbG9hZFVybCkgPyBoYW5kbGVVcGxvYWRVcmwgOiB0b0Fic29sdXRlVXJsKGhhbmRsZVVwbG9hZFVybCk7XG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIHR5cGU6IEV2ZW50VHlwZXMuZ2VuZXJhdGVDbGllbnRUb2tlbixcbiAgICBwYXlsb2FkOiB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIGNhbGxiYWNrVXJsOiB1cmwsXG4gICAgICBjbGllbnRQYXlsb2FkOiBvcHRpb25zLmNsaWVudFBheWxvYWQsXG4gICAgICBtdWx0aXBhcnQ6IG9wdGlvbnMubXVsdGlwYXJ0XG4gICAgfVxuICB9O1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGV2ZW50KSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH1cbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIkZhaWxlZCB0byAgcmV0cmlldmUgdGhlIGNsaWVudCB0b2tlblwiKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHsgY2xpZW50VG9rZW4gfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIGNsaWVudFRva2VuO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIkZhaWxlZCB0byByZXRyaWV2ZSB0aGUgY2xpZW50IHRva2VuXCIpO1xuICB9XG59XG5mdW5jdGlvbiB0b0Fic29sdXRlVXJsKHVybCkge1xuICByZXR1cm4gbmV3IFVSTCh1cmwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5ocmVmO1xufVxuZnVuY3Rpb24gaXNBYnNvbHV0ZVVybCh1cmwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gQm9vbGVhbihuZXcgVVJMKHVybCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuKHtcbiAgdG9rZW4sXG4gIC4uLmFyZ3NXaXRob3V0VG9rZW5cbn0pIHtcbiAgdmFyIF9hO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAnXCJnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuXCIgbXVzdCBiZSBjYWxsZWQgZnJvbSBhIHNlcnZlciBlbnZpcm9ubWVudCdcbiAgICApO1xuICB9XG4gIGNvbnN0IHRpbWVzdGFtcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICB0aW1lc3RhbXAuc2V0U2Vjb25kcyh0aW1lc3RhbXAuZ2V0U2Vjb25kcygpICsgMzApO1xuICBjb25zdCByZWFkV3JpdGVUb2tlbiA9IGdldFRva2VuRnJvbU9wdGlvbnNPckVudih7IHRva2VuIH0pO1xuICBjb25zdCBbLCAsICwgc3RvcmVJZCA9IG51bGxdID0gcmVhZFdyaXRlVG9rZW4uc3BsaXQoXCJfXCIpO1xuICBpZiAoIXN0b3JlSWQpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgdG9rZW4gPyBcIkludmFsaWQgYHRva2VuYCBwYXJhbWV0ZXJcIiA6IFwiSW52YWxpZCBgQkxPQl9SRUFEX1dSSVRFX1RPS0VOYFwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmZyb20oXG4gICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgLi4uYXJnc1dpdGhvdXRUb2tlbixcbiAgICAgIHZhbGlkVW50aWw6IChfYSA9IGFyZ3NXaXRob3V0VG9rZW4udmFsaWRVbnRpbCkgIT0gbnVsbCA/IF9hIDogdGltZXN0YW1wLmdldFRpbWUoKVxuICAgIH0pXG4gICkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gIGNvbnN0IHNlY3VyZWRLZXkgPSBhd2FpdCBzaWduUGF5bG9hZChwYXlsb2FkLCByZWFkV3JpdGVUb2tlbik7XG4gIGlmICghc2VjdXJlZEtleSkge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJVbmFibGUgdG8gc2lnbiBjbGllbnQgdG9rZW5cIik7XG4gIH1cbiAgcmV0dXJuIGB2ZXJjZWxfYmxvYl9jbGllbnRfJHtzdG9yZUlkfV8ke0J1ZmZlci5mcm9tKFxuICAgIGAke3NlY3VyZWRLZXl9LiR7cGF5bG9hZH1gXG4gICkudG9TdHJpbmcoXCJiYXNlNjRcIil9YDtcbn1cbmV4cG9ydCB7XG4gIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkLFxuICBjcmVhdGVNdWx0aXBhcnRVcGxvYWQsXG4gIGNyZWF0ZU11bHRpcGFydFVwbG9hZGVyLFxuICBnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuLFxuICBnZXRQYXlsb2FkRnJvbUNsaWVudFRva2VuLFxuICBoYW5kbGVVcGxvYWQsXG4gIHB1dCxcbiAgdXBsb2FkLFxuICB1cGxvYWRQYXJ0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: () => (/* reexport safe */ _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.BlobAccessError),\n/* harmony export */   BlobError: () => (/* reexport safe */ _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.BlobError),\n/* harmony export */   BlobNotFoundError: () => (/* reexport safe */ _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.BlobNotFoundError),\n/* harmony export */   BlobServiceNotAvailable: () => (/* reexport safe */ _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.BlobServiceNotAvailable),\n/* harmony export */   BlobStoreNotFoundError: () => (/* reexport safe */ _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.BlobStoreNotFoundError),\n/* harmony export */   BlobStoreSuspendedError: () => (/* reexport safe */ _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.BlobStoreSuspendedError),\n/* harmony export */   BlobUnknownError: () => (/* reexport safe */ _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.BlobUnknownError),\n/* harmony export */   completeMultipartUpload: () => (/* binding */ completeMultipartUpload),\n/* harmony export */   copy: () => (/* binding */ copy),\n/* harmony export */   createMultipartUpload: () => (/* binding */ createMultipartUpload),\n/* harmony export */   createMultipartUploader: () => (/* binding */ createMultipartUploader),\n/* harmony export */   del: () => (/* binding */ del),\n/* harmony export */   getDownloadUrl: () => (/* reexport safe */ _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.getDownloadUrl),\n/* harmony export */   head: () => (/* binding */ head),\n/* harmony export */   list: () => (/* binding */ list),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   uploadPart: () => (/* binding */ uploadPart)\n/* harmony export */ });\n/* harmony import */ var _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-IDKCY4S2.js */ \"(rsc)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/chunk-IDKCY4S2.js\");\n\n\n// src/del.ts\nasync function del(url, options) {\n  await (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    \"/delete\",\n    {\n      method: \"POST\",\n      headers: { \"content-type\": \"application/json\" },\n      body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] })\n    },\n    options\n  );\n}\n\n// src/head.ts\nasync function head(url, options) {\n  const searchParams = new URLSearchParams({ url });\n  const response = await (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    `?${searchParams.toString()}`,\n    // HEAD can't have body as a response, so we use GET\n    { method: \"GET\" },\n    options\n  );\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    size: response.size,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition,\n    cacheControl: response.cacheControl,\n    uploadedAt: new Date(response.uploadedAt)\n  };\n}\n\n// src/list.ts\nasync function list(options) {\n  var _a;\n  const searchParams = new URLSearchParams();\n  if (options == null ? void 0 : options.limit) {\n    searchParams.set(\"limit\", options.limit.toString());\n  }\n  if (options == null ? void 0 : options.prefix) {\n    searchParams.set(\"prefix\", options.prefix);\n  }\n  if (options == null ? void 0 : options.cursor) {\n    searchParams.set(\"cursor\", options.cursor);\n  }\n  if (options == null ? void 0 : options.mode) {\n    searchParams.set(\"mode\", options.mode);\n  }\n  const response = await (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    `?${searchParams.toString()}`,\n    { method: \"GET\" },\n    options\n  );\n  if ((options == null ? void 0 : options.mode) === \"folded\") {\n    return {\n      folders: (_a = response.folders) != null ? _a : [],\n      cursor: response.cursor,\n      hasMore: response.hasMore,\n      blobs: response.blobs.map(mapBlobResult)\n    };\n  }\n  return {\n    cursor: response.cursor,\n    hasMore: response.hasMore,\n    blobs: response.blobs.map(mapBlobResult)\n  };\n}\nfunction mapBlobResult(blobResult) {\n  return {\n    url: blobResult.url,\n    downloadUrl: blobResult.downloadUrl,\n    pathname: blobResult.pathname,\n    size: blobResult.size,\n    uploadedAt: new Date(blobResult.uploadedAt)\n  };\n}\n\n// src/copy.ts\nasync function copy(fromUrl, toPathname, options) {\n  if (!options) {\n    throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.BlobError('access must be \"public\"');\n  }\n  const headers = {};\n  if (options.addRandomSuffix !== void 0) {\n    headers[\"x-add-random-suffix\"] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (options.contentType) {\n    headers[\"x-content-type\"] = options.contentType;\n  }\n  if (options.cacheControlMaxAge !== void 0) {\n    headers[\"x-cache-control-max-age\"] = options.cacheControlMaxAge.toString();\n  }\n  const response = await (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    `/${toPathname}?fromUrl=${fromUrl}`,\n    { method: \"PUT\", headers },\n    options\n  );\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition\n  };\n}\n\n// src/index.ts\nvar put = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.createPutMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar createMultipartUpload = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.createCreateMultipartUploadMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar createMultipartUploader = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.createCreateMultipartUploaderMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar uploadPart = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.createUploadPartMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar completeMultipartUpload = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_0__.createCompleteMultipartUploadMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZlcmNlbCtibG9iQDAuMjIuMy9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZTZCOztBQUU3QjtBQUNBO0FBQ0EsUUFBUSw4REFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JELDZCQUE2Qix3Q0FBd0M7QUFDckUsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQseUJBQXlCLDhEQUFVO0FBQ25DLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0EsTUFBTSxlQUFlO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhEQUFVO0FBQ25DLFFBQVEsd0JBQXdCO0FBQ2hDLE1BQU0sZUFBZTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlEQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLHlEQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOERBQVU7QUFDbkMsUUFBUSxXQUFXLFdBQVcsUUFBUTtBQUN0QyxNQUFNLHdCQUF3QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsbUVBQWU7QUFDekI7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCLHFGQUFpQztBQUM3RDtBQUNBLENBQUM7QUFDRCw4QkFBOEIsdUZBQW1DO0FBQ2pFO0FBQ0EsQ0FBQztBQUNELGlCQUFpQiwwRUFBc0I7QUFDdkM7QUFDQSxDQUFDO0FBQ0QsOEJBQThCLHVGQUFtQztBQUNqRTtBQUNBLENBQUM7QUFtQkM7QUFDRiIsInNvdXJjZXMiOlsiQzpcXHByb2plY3RzXFxhdXRoXFxub2RlX21vZHVsZXNcXC5wbnBtXFxAdmVyY2VsK2Jsb2JAMC4yMi4zXFxub2RlX21vZHVsZXNcXEB2ZXJjZWxcXGJsb2JcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJsb2JBY2Nlc3NFcnJvcixcbiAgQmxvYkVycm9yLFxuICBCbG9iTm90Rm91bmRFcnJvcixcbiAgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUsXG4gIEJsb2JTdG9yZU5vdEZvdW5kRXJyb3IsXG4gIEJsb2JTdG9yZVN1c3BlbmRlZEVycm9yLFxuICBCbG9iVW5rbm93bkVycm9yLFxuICBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kLFxuICBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCxcbiAgY3JlYXRlUHV0TWV0aG9kLFxuICBjcmVhdGVVcGxvYWRQYXJ0TWV0aG9kLFxuICBnZXREb3dubG9hZFVybCxcbiAgcmVxdWVzdEFwaVxufSBmcm9tIFwiLi9jaHVuay1JREtDWTRTMi5qc1wiO1xuXG4vLyBzcmMvZGVsLnRzXG5hc3luYyBmdW5jdGlvbiBkZWwodXJsLCBvcHRpb25zKSB7XG4gIGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgXCIvZGVsZXRlXCIsXG4gICAge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXJsczogQXJyYXkuaXNBcnJheSh1cmwpID8gdXJsIDogW3VybF0gfSlcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cblxuLy8gc3JjL2hlYWQudHNcbmFzeW5jIGZ1bmN0aW9uIGhlYWQodXJsLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyB1cmwgfSk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICBgPyR7c2VhcmNoUGFyYW1zLnRvU3RyaW5nKCl9YCxcbiAgICAvLyBIRUFEIGNhbid0IGhhdmUgYm9keSBhcyBhIHJlc3BvbnNlLCBzbyB3ZSB1c2UgR0VUXG4gICAgeyBtZXRob2Q6IFwiR0VUXCIgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIHJldHVybiB7XG4gICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgZG93bmxvYWRVcmw6IHJlc3BvbnNlLmRvd25sb2FkVXJsLFxuICAgIHBhdGhuYW1lOiByZXNwb25zZS5wYXRobmFtZSxcbiAgICBzaXplOiByZXNwb25zZS5zaXplLFxuICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5jb250ZW50VHlwZSxcbiAgICBjb250ZW50RGlzcG9zaXRpb246IHJlc3BvbnNlLmNvbnRlbnREaXNwb3NpdGlvbixcbiAgICBjYWNoZUNvbnRyb2w6IHJlc3BvbnNlLmNhY2hlQ29udHJvbCxcbiAgICB1cGxvYWRlZEF0OiBuZXcgRGF0ZShyZXNwb25zZS51cGxvYWRlZEF0KVxuICB9O1xufVxuXG4vLyBzcmMvbGlzdC50c1xuYXN5bmMgZnVuY3Rpb24gbGlzdChvcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5saW1pdCkge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJsaW1pdFwiLCBvcHRpb25zLmxpbWl0LnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnByZWZpeCkge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJwcmVmaXhcIiwgb3B0aW9ucy5wcmVmaXgpO1xuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmN1cnNvcikge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJjdXJzb3JcIiwgb3B0aW9ucy5jdXJzb3IpO1xuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGUpIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwibW9kZVwiLCBvcHRpb25zLm1vZGUpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICBgPyR7c2VhcmNoUGFyYW1zLnRvU3RyaW5nKCl9YCxcbiAgICB7IG1ldGhvZDogXCJHRVRcIiB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgaWYgKChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGUpID09PSBcImZvbGRlZFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbGRlcnM6IChfYSA9IHJlc3BvbnNlLmZvbGRlcnMpICE9IG51bGwgPyBfYSA6IFtdLFxuICAgICAgY3Vyc29yOiByZXNwb25zZS5jdXJzb3IsXG4gICAgICBoYXNNb3JlOiByZXNwb25zZS5oYXNNb3JlLFxuICAgICAgYmxvYnM6IHJlc3BvbnNlLmJsb2JzLm1hcChtYXBCbG9iUmVzdWx0KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjdXJzb3I6IHJlc3BvbnNlLmN1cnNvcixcbiAgICBoYXNNb3JlOiByZXNwb25zZS5oYXNNb3JlLFxuICAgIGJsb2JzOiByZXNwb25zZS5ibG9icy5tYXAobWFwQmxvYlJlc3VsdClcbiAgfTtcbn1cbmZ1bmN0aW9uIG1hcEJsb2JSZXN1bHQoYmxvYlJlc3VsdCkge1xuICByZXR1cm4ge1xuICAgIHVybDogYmxvYlJlc3VsdC51cmwsXG4gICAgZG93bmxvYWRVcmw6IGJsb2JSZXN1bHQuZG93bmxvYWRVcmwsXG4gICAgcGF0aG5hbWU6IGJsb2JSZXN1bHQucGF0aG5hbWUsXG4gICAgc2l6ZTogYmxvYlJlc3VsdC5zaXplLFxuICAgIHVwbG9hZGVkQXQ6IG5ldyBEYXRlKGJsb2JSZXN1bHQudXBsb2FkZWRBdClcbiAgfTtcbn1cblxuLy8gc3JjL2NvcHkudHNcbmFzeW5jIGZ1bmN0aW9uIGNvcHkoZnJvbVVybCwgdG9QYXRobmFtZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwibWlzc2luZyBvcHRpb25zLCBzZWUgdXNhZ2VcIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWNjZXNzICE9PSBcInB1YmxpY1wiKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcignYWNjZXNzIG11c3QgYmUgXCJwdWJsaWNcIicpO1xuICB9XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKG9wdGlvbnMuYWRkUmFuZG9tU3VmZml4ICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzW1wieC1hZGQtcmFuZG9tLXN1ZmZpeFwiXSA9IG9wdGlvbnMuYWRkUmFuZG9tU3VmZml4ID8gXCIxXCIgOiBcIjBcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5jb250ZW50VHlwZSkge1xuICAgIGhlYWRlcnNbXCJ4LWNvbnRlbnQtdHlwZVwiXSA9IG9wdGlvbnMuY29udGVudFR5cGU7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzW1wieC1jYWNoZS1jb250cm9sLW1heC1hZ2VcIl0gPSBvcHRpb25zLmNhY2hlQ29udHJvbE1heEFnZS50b1N0cmluZygpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICBgLyR7dG9QYXRobmFtZX0/ZnJvbVVybD0ke2Zyb21Vcmx9YCxcbiAgICB7IG1ldGhvZDogXCJQVVRcIiwgaGVhZGVycyB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICBkb3dubG9hZFVybDogcmVzcG9uc2UuZG93bmxvYWRVcmwsXG4gICAgcGF0aG5hbWU6IHJlc3BvbnNlLnBhdGhuYW1lLFxuICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5jb250ZW50VHlwZSxcbiAgICBjb250ZW50RGlzcG9zaXRpb246IHJlc3BvbnNlLmNvbnRlbnREaXNwb3NpdGlvblxuICB9O1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBwdXQgPSBjcmVhdGVQdXRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY2FjaGVDb250cm9sTWF4QWdlXCIsIFwiYWRkUmFuZG9tU3VmZml4XCIsIFwiY29udGVudFR5cGVcIl1cbn0pO1xudmFyIGNyZWF0ZU11bHRpcGFydFVwbG9hZCA9IGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjYWNoZUNvbnRyb2xNYXhBZ2VcIiwgXCJhZGRSYW5kb21TdWZmaXhcIiwgXCJjb250ZW50VHlwZVwiXVxufSk7XG52YXIgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXIgPSBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjYWNoZUNvbnRyb2xNYXhBZ2VcIiwgXCJhZGRSYW5kb21TdWZmaXhcIiwgXCJjb250ZW50VHlwZVwiXVxufSk7XG52YXIgdXBsb2FkUGFydCA9IGNyZWF0ZVVwbG9hZFBhcnRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY2FjaGVDb250cm9sTWF4QWdlXCIsIFwiYWRkUmFuZG9tU3VmZml4XCIsIFwiY29udGVudFR5cGVcIl1cbn0pO1xudmFyIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkID0gY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY2FjaGVDb250cm9sTWF4QWdlXCIsIFwiYWRkUmFuZG9tU3VmZml4XCIsIFwiY29udGVudFR5cGVcIl1cbn0pO1xuZXhwb3J0IHtcbiAgQmxvYkFjY2Vzc0Vycm9yLFxuICBCbG9iRXJyb3IsXG4gIEJsb2JOb3RGb3VuZEVycm9yLFxuICBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSxcbiAgQmxvYlN0b3JlTm90Rm91bmRFcnJvcixcbiAgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IsXG4gIEJsb2JVbmtub3duRXJyb3IsXG4gIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkLFxuICBjb3B5LFxuICBjcmVhdGVNdWx0aXBhcnRVcGxvYWQsXG4gIGNyZWF0ZU11bHRpcGFydFVwbG9hZGVyLFxuICBkZWwsXG4gIGdldERvd25sb2FkVXJsLFxuICBoZWFkLFxuICBsaXN0LFxuICBwdXQsXG4gIHVwbG9hZFBhcnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/chunk-IDKCY4S2.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/chunk-IDKCY4S2.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: () => (/* binding */ BlobAccessError),\n/* harmony export */   BlobError: () => (/* binding */ BlobError),\n/* harmony export */   BlobNotFoundError: () => (/* binding */ BlobNotFoundError),\n/* harmony export */   BlobServiceNotAvailable: () => (/* binding */ BlobServiceNotAvailable),\n/* harmony export */   BlobStoreNotFoundError: () => (/* binding */ BlobStoreNotFoundError),\n/* harmony export */   BlobStoreSuspendedError: () => (/* binding */ BlobStoreSuspendedError),\n/* harmony export */   BlobUnknownError: () => (/* binding */ BlobUnknownError),\n/* harmony export */   createCompleteMultipartUploadMethod: () => (/* binding */ createCompleteMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploadMethod: () => (/* binding */ createCreateMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploaderMethod: () => (/* binding */ createCreateMultipartUploaderMethod),\n/* harmony export */   createPutMethod: () => (/* binding */ createPutMethod),\n/* harmony export */   createUploadPartMethod: () => (/* binding */ createUploadPartMethod),\n/* harmony export */   getDownloadUrl: () => (/* binding */ getDownloadUrl),\n/* harmony export */   getTokenFromOptionsOrEnv: () => (/* binding */ getTokenFromOptionsOrEnv),\n/* harmony export */   requestApi: () => (/* binding */ requestApi)\n/* harmony export */ });\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! undici */ \"(ssr)/./node_modules/.pnpm/undici@5.29.0/node_modules/undici/index.js\");\n/* harmony import */ var async_retry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! async-retry */ \"(ssr)/./node_modules/.pnpm/async-retry@1.3.3/node_modules/async-retry/lib/index.js\");\n/* harmony import */ var bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bytes */ \"(ssr)/./node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! is-buffer */ \"(ssr)/./node_modules/.pnpm/is-buffer@2.0.5/node_modules/is-buffer/index.js\");\n// src/helpers.ts\nfunction getTokenFromOptionsOrEnv(options) {\n  if (options == null ? void 0 : options.token) {\n    return options.token;\n  }\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n  throw new BlobError(\n    \"No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.\"\n  );\n}\nvar BlobError = class extends Error {\n  constructor(message) {\n    super(`Vercel Blob: ${message}`);\n  }\n};\nfunction getDownloadUrl(blobUrl) {\n  const url = new URL(blobUrl);\n  url.searchParams.set(\"download\", \"1\");\n  return url.toString();\n}\n\n// src/api.ts\n\n\n\n// src/debug.ts\nvar debugIsActive = false;\nvar _a, _b;\ntry {\n  if (((_a = process.env.DEBUG) == null ? void 0 : _a.includes(\"blob\")) || ((_b = process.env.NEXT_PUBLIC_DEBUG) == null ? void 0 : _b.includes(\"blob\"))) {\n    debugIsActive = true;\n  }\n} catch (error) {\n}\nfunction debug(message, ...args) {\n  if (debugIsActive) {\n    console.debug(`vercel-blob: ${message}`, ...args);\n  }\n}\n\n// src/api.ts\nvar BlobAccessError = class extends BlobError {\n  constructor() {\n    super(\"Access denied, please provide a valid token for this resource.\");\n  }\n};\nvar BlobStoreNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"This store does not exist.\");\n  }\n};\nvar BlobStoreSuspendedError = class extends BlobError {\n  constructor() {\n    super(\"This store has been suspended.\");\n  }\n};\nvar BlobUnknownError = class extends BlobError {\n  constructor() {\n    super(\"Unknown error, please visit https://vercel.com/help.\");\n  }\n};\nvar BlobNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"The requested blob does not exist\");\n  }\n};\nvar BlobServiceNotAvailable = class extends BlobError {\n  constructor() {\n    super(\"The blob service is currently not available. Please try again.\");\n  }\n};\nvar BlobServiceRateLimited = class extends BlobError {\n  constructor(seconds) {\n    super(\n      `Too many requests please lower the number of concurrent requests ${seconds ? ` - try again in ${seconds} seconds` : \"\"}.`\n    );\n    this.retryAfter = seconds != null ? seconds : 0;\n  }\n};\nvar BLOB_API_VERSION = 7;\nfunction getApiVersion() {\n  let versionOverride = null;\n  try {\n    versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n  }\n  return `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`;\n}\nfunction getApiUrl(pathname = \"\") {\n  let baseUrl = null;\n  try {\n    baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n  }\n  return `${baseUrl || \"https://blob.vercel-storage.com\"}${pathname}`;\n}\nfunction getRetries() {\n  try {\n    const retries = process.env.VERCEL_BLOB_RETRIES || \"10\";\n    return parseInt(retries, 10);\n  } catch {\n    return 10;\n  }\n}\nfunction createBlobServiceRateLimited(response) {\n  const retryAfter = response.headers.get(\"retry-after\");\n  return new BlobServiceRateLimited(\n    retryAfter ? parseInt(retryAfter, 10) : void 0\n  );\n}\nasync function getBlobError(response) {\n  var _a2, _b2, _c;\n  let code;\n  let message;\n  try {\n    const data = await response.json();\n    code = (_b2 = (_a2 = data.error) == null ? void 0 : _a2.code) != null ? _b2 : \"unknown_error\";\n    message = (_c = data.error) == null ? void 0 : _c.message;\n  } catch {\n    code = \"unknown_error\";\n  }\n  let error;\n  switch (code) {\n    case \"store_suspended\":\n      error = new BlobStoreSuspendedError();\n      break;\n    case \"forbidden\":\n      error = new BlobAccessError();\n      break;\n    case \"not_found\":\n      error = new BlobNotFoundError();\n      break;\n    case \"store_not_found\":\n      error = new BlobStoreNotFoundError();\n      break;\n    case \"bad_request\":\n      error = new BlobError(message != null ? message : \"Bad request\");\n      break;\n    case \"service_unavailable\":\n      error = new BlobServiceNotAvailable();\n      break;\n    case \"rate_limited\":\n      error = createBlobServiceRateLimited(response);\n      break;\n    case \"unknown_error\":\n    case \"not_allowed\":\n    default:\n      error = new BlobUnknownError();\n      break;\n  }\n  return { code, error };\n}\nasync function requestApi(pathname, init, commandOptions) {\n  const apiVersion = getApiVersion();\n  const token = getTokenFromOptionsOrEnv(commandOptions);\n  const apiResponse = await async_retry__WEBPACK_IMPORTED_MODULE_1__(\n    async (bail) => {\n      const res = await (0,undici__WEBPACK_IMPORTED_MODULE_0__.fetch)(getApiUrl(pathname), {\n        ...init,\n        headers: {\n          \"x-api-version\": apiVersion,\n          authorization: `Bearer ${token}`,\n          ...init.headers\n        }\n      });\n      if (res.ok) {\n        return res;\n      }\n      const { code, error } = await getBlobError(res);\n      if (code === \"unknown_error\" || code === \"service_unavailable\") {\n        throw error;\n      }\n      bail(error);\n    },\n    {\n      retries: getRetries(),\n      onRetry: (error) => {\n        debug(`retrying API request to ${pathname}`, error.message);\n      }\n    }\n  );\n  if (!apiResponse) {\n    throw new BlobUnknownError();\n  }\n  return await apiResponse.json();\n}\n\n// src/put-helpers.ts\nvar putOptionHeaderMap = {\n  cacheControlMaxAge: \"x-cache-control-max-age\",\n  addRandomSuffix: \"x-add-random-suffix\",\n  contentType: \"x-content-type\"\n};\nfunction createPutHeaders(allowedOptions, options) {\n  const headers = {};\n  if (allowedOptions.includes(\"contentType\") && options.contentType) {\n    headers[putOptionHeaderMap.contentType] = options.contentType;\n  }\n  if (allowedOptions.includes(\"addRandomSuffix\") && options.addRandomSuffix !== void 0) {\n    headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (allowedOptions.includes(\"cacheControlMaxAge\") && options.cacheControlMaxAge !== void 0) {\n    headers[putOptionHeaderMap.cacheControlMaxAge] = options.cacheControlMaxAge.toString();\n  }\n  return headers;\n}\nasync function createPutOptions({\n  pathname,\n  options,\n  extraChecks,\n  getToken\n}) {\n  if (!pathname) {\n    throw new BlobError(\"pathname is required\");\n  }\n  if (!options) {\n    throw new BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new BlobError('access must be \"public\"');\n  }\n  if (extraChecks) {\n    extraChecks(options);\n  }\n  if (getToken) {\n    options.token = await getToken(pathname, options);\n  }\n  return options;\n}\n\n// src/multipart/complete.ts\nfunction createCompleteMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, parts, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    return completeMultipartUpload({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      headers,\n      options,\n      parts\n    });\n  };\n}\nasync function completeMultipartUpload({\n  uploadId,\n  key,\n  pathname,\n  parts,\n  headers,\n  options\n}) {\n  try {\n    const response = await requestApi(\n      `/mpu/${pathname}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"content-type\": \"application/json\",\n          \"x-mpu-action\": \"complete\",\n          \"x-mpu-upload-id\": uploadId,\n          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n          // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n          \"x-mpu-key\": encodeURI(key)\n        },\n        body: JSON.stringify(parts)\n      },\n      options\n    );\n    debug(\"mpu: complete\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\n// src/multipart/create.ts\nfunction createCreateMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId\n    };\n  };\n}\nasync function createMultipartUpload(pathname, headers, options) {\n  debug(\"mpu: create\", \"pathname:\", pathname);\n  try {\n    const response = await requestApi(\n      `/mpu/${pathname}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"x-mpu-action\": \"create\"\n        }\n      },\n      options\n    );\n    debug(\"mpu: create\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\n// src/multipart/upload.ts\n\nfunction createUploadPartMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, body, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const result = await uploadPart({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      part: { blob: body, partNumber: options.partNumber },\n      headers,\n      options,\n      abortController: options.abortController\n    });\n    return {\n      etag: result.etag,\n      partNumber: options.partNumber\n    };\n  };\n}\nfunction uploadPart({\n  uploadId,\n  key,\n  pathname,\n  headers,\n  options,\n  abortController,\n  part\n}) {\n  return requestApi(\n    `/mpu/${pathname}`,\n    {\n      signal: abortController == null ? void 0 : abortController.signal,\n      method: \"POST\",\n      headers: {\n        ...headers,\n        \"x-mpu-action\": \"upload\",\n        \"x-mpu-key\": encodeURI(key),\n        \"x-mpu-upload-id\": uploadId,\n        \"x-mpu-part-number\": part.partNumber.toString()\n      },\n      // weird things between undici types and native fetch types\n      body: part.blob,\n      // required in order to stream some body types to Cloudflare\n      // currently only supported in Node.js, we may have to feature detect this\n      duplex: \"half\"\n    },\n    options\n  );\n}\nvar maxConcurrentUploads = typeof window !== \"undefined\" ? 6 : 8;\nvar partSizeInBytes = 8 * 1024 * 1024;\nvar maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\nfunction uploadAllParts({\n  uploadId,\n  key,\n  pathname,\n  stream,\n  headers,\n  options\n}) {\n  debug(\"mpu: upload init\", \"key:\", key);\n  const internalAbortController = new AbortController();\n  return new Promise((resolve, reject) => {\n    const partsToUpload = [];\n    const completedParts = [];\n    const reader = stream.getReader();\n    let activeUploads = 0;\n    let reading = false;\n    let currentPartNumber = 1;\n    let rejected = false;\n    let currentBytesInMemory = 0;\n    let doneReading = false;\n    let bytesSent = 0;\n    let arrayBuffers = [];\n    let currentPartBytesRead = 0;\n    read().catch(cancel);\n    async function read() {\n      debug(\n        \"mpu: upload read start\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_2__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_2__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_2__(bytesSent)\n      );\n      reading = true;\n      while (currentBytesInMemory < maxBytesInMemory && !rejected) {\n        try {\n          const { value, done } = await reader.read();\n          if (done) {\n            doneReading = true;\n            debug(\"mpu: upload read consumed the whole stream\");\n            if (arrayBuffers.length > 0) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              sendParts();\n            }\n            reading = false;\n            return;\n          }\n          currentBytesInMemory += value.byteLength;\n          let valueOffset = 0;\n          while (valueOffset < value.byteLength) {\n            const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n            const endOffset = Math.min(\n              valueOffset + remainingPartSize,\n              value.byteLength\n            );\n            const chunk = value.slice(valueOffset, endOffset);\n            arrayBuffers.push(chunk);\n            currentPartBytesRead += chunk.byteLength;\n            valueOffset = endOffset;\n            if (currentPartBytesRead === partSizeInBytes) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              arrayBuffers = [];\n              currentPartBytesRead = 0;\n              sendParts();\n            }\n          }\n        } catch (error) {\n          cancel(error);\n        }\n      }\n      debug(\n        \"mpu: upload read end\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_2__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_2__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_2__(bytesSent)\n      );\n      reading = false;\n    }\n    async function sendPart(part) {\n      activeUploads++;\n      debug(\n        \"mpu: upload send part start\",\n        \"partNumber:\",\n        part.partNumber,\n        \"size:\",\n        part.blob.size,\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_2__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_2__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_2__(bytesSent)\n      );\n      try {\n        const completedPart = await uploadPart({\n          uploadId,\n          key,\n          pathname,\n          headers,\n          options,\n          abortController: internalAbortController,\n          part\n        });\n        debug(\n          \"mpu: upload send part end\",\n          \"partNumber:\",\n          part.partNumber,\n          \"activeUploads\",\n          activeUploads,\n          \"currentBytesInMemory:\",\n          `${bytes__WEBPACK_IMPORTED_MODULE_2__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_2__(maxBytesInMemory)}`,\n          \"bytesSent:\",\n          bytes__WEBPACK_IMPORTED_MODULE_2__(bytesSent)\n        );\n        if (rejected) {\n          return;\n        }\n        completedParts.push({\n          partNumber: part.partNumber,\n          etag: completedPart.etag\n        });\n        currentBytesInMemory -= part.blob.size;\n        activeUploads--;\n        bytesSent += part.blob.size;\n        if (partsToUpload.length > 0) {\n          sendParts();\n        }\n        if (doneReading) {\n          if (activeUploads === 0) {\n            reader.releaseLock();\n            resolve(completedParts);\n          }\n          return;\n        }\n        if (!reading) {\n          read().catch(cancel);\n        }\n      } catch (error) {\n        cancel(error);\n      }\n    }\n    function sendParts() {\n      if (rejected) {\n        return;\n      }\n      debug(\n        \"send parts\",\n        \"activeUploads\",\n        activeUploads,\n        \"partsToUpload\",\n        partsToUpload.length\n      );\n      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {\n        const partToSend = partsToUpload.shift();\n        if (partToSend) {\n          void sendPart(partToSend);\n        }\n      }\n    }\n    function cancel(error) {\n      if (rejected) {\n        return;\n      }\n      rejected = true;\n      internalAbortController.abort();\n      reader.releaseLock();\n      if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n        reject(new BlobServiceNotAvailable());\n      } else {\n        reject(error);\n      }\n    }\n  });\n}\n\n// src/multipart/helpers.ts\n\n\nfunction toReadableStream(value) {\n  if (value instanceof ReadableStream) {\n    return value;\n  }\n  if (value instanceof Blob) {\n    return value.stream();\n  }\n  if (isNodeJsReadableStream(value)) {\n    return stream__WEBPACK_IMPORTED_MODULE_3__.Readable.toWeb(value);\n  }\n  let streamValue;\n  if (value instanceof ArrayBuffer) {\n    streamValue = value;\n  } else if (isNodeJsBufferOrString(value)) {\n    streamValue = value.buffer;\n  } else {\n    streamValue = stringToUint8Array(value);\n  }\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(streamValue);\n      controller.close();\n    }\n  });\n}\nfunction isNodeJsReadableStream(value) {\n  return typeof value === \"object\" && typeof value.pipe === \"function\" && value.readable && typeof value._read === \"function\" && // @ts-expect-error _readableState does exists on Readable\n  typeof value._readableState === \"object\";\n}\nfunction stringToUint8Array(s) {\n  const enc = new TextEncoder();\n  return enc.encode(s);\n}\nfunction isNodeJsBufferOrString(input) {\n  return is_buffer__WEBPACK_IMPORTED_MODULE_4__(input);\n}\n\n// src/multipart/uncontrolled.ts\nasync function uncontrolledMultipartUpload(pathname, body, headers, options) {\n  debug(\"mpu: init\", \"pathname:\", pathname, \"headers:\", headers);\n  const stream = toReadableStream(body);\n  const createMultipartUploadResponse = await createMultipartUpload(\n    pathname,\n    headers,\n    options\n  );\n  const parts = await uploadAllParts({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    stream,\n    headers,\n    options\n  });\n  const blob = await completeMultipartUpload({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    parts,\n    headers,\n    options\n  });\n  return blob;\n}\n\n// src/put.ts\nfunction createPutMethod({\n  allowedOptions,\n  getToken,\n  extraChecks\n}) {\n  return async function put(pathname, bodyOrOptions, optionsInput) {\n    const isFolderCreation = pathname.endsWith(\"/\");\n    if (!bodyOrOptions && !isFolderCreation) {\n      throw new BlobError(\"body is required\");\n    }\n    if (bodyOrOptions && optionsInput && isFolderCreation) {\n      throw new BlobError(\"body is not allowed for creating empty folders\");\n    }\n    const body = isFolderCreation ? void 0 : bodyOrOptions;\n    const options = await createPutOptions({\n      pathname,\n      // when no body is required (for folder creations) options are the second argument\n      options: isFolderCreation ? bodyOrOptions : optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (options.multipart === true && body) {\n      return uncontrolledMultipartUpload(pathname, body, headers, options);\n    }\n    const response = await requestApi(\n      `/${pathname}`,\n      {\n        method: \"PUT\",\n        body,\n        headers,\n        // required in order to stream some body types to Cloudflare\n        // currently only supported in Node.js, we may have to feature detect this\n        duplex: \"half\"\n      },\n      options\n    );\n    return {\n      url: response.url,\n      downloadUrl: response.downloadUrl,\n      pathname: response.pathname,\n      contentType: response.contentType,\n      contentDisposition: response.contentDisposition\n    };\n  };\n}\n\n// src/multipart/create-uploader.ts\nfunction createCreateMultipartUploaderMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n      async uploadPart(partNumber, body) {\n        const result = await uploadPart({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          part: { partNumber, blob: body },\n          headers,\n          options\n        });\n        return {\n          etag: result.etag,\n          partNumber\n        };\n      },\n      async complete(parts) {\n        return completeMultipartUpload({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          parts,\n          headers,\n          options\n        });\n      }\n    };\n  };\n}\n\n\n//# sourceMappingURL=chunk-IDKCY4S2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZlcmNlbCtibG9iQDAuMjIuMy9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2h1bmstSURLQ1k0UzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDK0I7QUFDQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw2QkFBNkIsU0FBUyxjQUFjO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFlBQVksNkRBQTZEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxZQUFZLDZDQUE2QyxFQUFFLFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQWtCRTtBQUNGIiwic291cmNlcyI6WyJDOlxccHJvamVjdHNcXGF1dGhcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEB2ZXJjZWwrYmxvYkAwLjIyLjNcXG5vZGVfbW9kdWxlc1xcQHZlcmNlbFxcYmxvYlxcZGlzdFxcY2h1bmstSURLQ1k0UzIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2hlbHBlcnMudHNcbmZ1bmN0aW9uIGdldFRva2VuRnJvbU9wdGlvbnNPckVudihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRva2VuKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudG9rZW47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52LkJMT0JfUkVBRF9XUklURV9UT0tFTikge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5CTE9CX1JFQURfV1JJVEVfVE9LRU47XG4gIH1cbiAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICBcIk5vIHRva2VuIGZvdW5kLiBFaXRoZXIgY29uZmlndXJlIHRoZSBgQkxPQl9SRUFEX1dSSVRFX1RPS0VOYCBlbnZpcm9ubWVudCB2YXJpYWJsZSwgb3IgcGFzcyBhIGB0b2tlbmAgb3B0aW9uIHRvIHlvdXIgY2FsbHMuXCJcbiAgKTtcbn1cbnZhciBCbG9iRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKGBWZXJjZWwgQmxvYjogJHttZXNzYWdlfWApO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0RG93bmxvYWRVcmwoYmxvYlVybCkge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKGJsb2JVcmwpO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldChcImRvd25sb2FkXCIsIFwiMVwiKTtcbiAgcmV0dXJuIHVybC50b1N0cmluZygpO1xufVxuXG4vLyBzcmMvYXBpLnRzXG5pbXBvcnQgeyBmZXRjaCB9IGZyb20gXCJ1bmRpY2lcIjtcbmltcG9ydCByZXRyeSBmcm9tIFwiYXN5bmMtcmV0cnlcIjtcblxuLy8gc3JjL2RlYnVnLnRzXG52YXIgZGVidWdJc0FjdGl2ZSA9IGZhbHNlO1xudmFyIF9hLCBfYjtcbnRyeSB7XG4gIGlmICgoKF9hID0gcHJvY2Vzcy5lbnYuREVCVUcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhcImJsb2JcIikpIHx8ICgoX2IgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19ERUJVRykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwiYmxvYlwiKSkpIHtcbiAgICBkZWJ1Z0lzQWN0aXZlID0gdHJ1ZTtcbiAgfVxufSBjYXRjaCAoZXJyb3IpIHtcbn1cbmZ1bmN0aW9uIGRlYnVnKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcbiAgaWYgKGRlYnVnSXNBY3RpdmUpIHtcbiAgICBjb25zb2xlLmRlYnVnKGB2ZXJjZWwtYmxvYjogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xuICB9XG59XG5cbi8vIHNyYy9hcGkudHNcbnZhciBCbG9iQWNjZXNzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiQWNjZXNzIGRlbmllZCwgcGxlYXNlIHByb3ZpZGUgYSB2YWxpZCB0b2tlbiBmb3IgdGhpcyByZXNvdXJjZS5cIik7XG4gIH1cbn07XG52YXIgQmxvYlN0b3JlTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGlzIHN0b3JlIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgfVxufTtcbnZhciBCbG9iU3RvcmVTdXNwZW5kZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGlzIHN0b3JlIGhhcyBiZWVuIHN1c3BlbmRlZC5cIik7XG4gIH1cbn07XG52YXIgQmxvYlVua25vd25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJVbmtub3duIGVycm9yLCBwbGVhc2UgdmlzaXQgaHR0cHM6Ly92ZXJjZWwuY29tL2hlbHAuXCIpO1xuICB9XG59O1xudmFyIEJsb2JOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoZSByZXF1ZXN0ZWQgYmxvYiBkb2VzIG5vdCBleGlzdFwiKTtcbiAgfVxufTtcbnZhciBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGUgYmxvYiBzZXJ2aWNlIGlzIGN1cnJlbnRseSBub3QgYXZhaWxhYmxlLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgfVxufTtcbnZhciBCbG9iU2VydmljZVJhdGVMaW1pdGVkID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzZWNvbmRzKSB7XG4gICAgc3VwZXIoXG4gICAgICBgVG9vIG1hbnkgcmVxdWVzdHMgcGxlYXNlIGxvd2VyIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCByZXF1ZXN0cyAke3NlY29uZHMgPyBgIC0gdHJ5IGFnYWluIGluICR7c2Vjb25kc30gc2Vjb25kc2AgOiBcIlwifS5gXG4gICAgKTtcbiAgICB0aGlzLnJldHJ5QWZ0ZXIgPSBzZWNvbmRzICE9IG51bGwgPyBzZWNvbmRzIDogMDtcbiAgfVxufTtcbnZhciBCTE9CX0FQSV9WRVJTSU9OID0gNztcbmZ1bmN0aW9uIGdldEFwaVZlcnNpb24oKSB7XG4gIGxldCB2ZXJzaW9uT3ZlcnJpZGUgPSBudWxsO1xuICB0cnkge1xuICAgIHZlcnNpb25PdmVycmlkZSA9IHByb2Nlc3MuZW52LlZFUkNFTF9CTE9CX0FQSV9WRVJTSU9OX09WRVJSSURFIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX0FQSV9WRVJTSU9OX09WRVJSSURFO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gYCR7dmVyc2lvbk92ZXJyaWRlICE9IG51bGwgPyB2ZXJzaW9uT3ZlcnJpZGUgOiBCTE9CX0FQSV9WRVJTSU9OfWA7XG59XG5mdW5jdGlvbiBnZXRBcGlVcmwocGF0aG5hbWUgPSBcIlwiKSB7XG4gIGxldCBiYXNlVXJsID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBiYXNlVXJsID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfQVBJX1VSTCB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVVJMO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gYCR7YmFzZVVybCB8fCBcImh0dHBzOi8vYmxvYi52ZXJjZWwtc3RvcmFnZS5jb21cIn0ke3BhdGhuYW1lfWA7XG59XG5mdW5jdGlvbiBnZXRSZXRyaWVzKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJldHJpZXMgPSBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9SRVRSSUVTIHx8IFwiMTBcIjtcbiAgICByZXR1cm4gcGFyc2VJbnQocmV0cmllcywgMTApO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gMTA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQocmVzcG9uc2UpIHtcbiAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwicmV0cnktYWZ0ZXJcIik7XG4gIHJldHVybiBuZXcgQmxvYlNlcnZpY2VSYXRlTGltaXRlZChcbiAgICByZXRyeUFmdGVyID8gcGFyc2VJbnQocmV0cnlBZnRlciwgMTApIDogdm9pZCAwXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCbG9iRXJyb3IocmVzcG9uc2UpIHtcbiAgdmFyIF9hMiwgX2IyLCBfYztcbiAgbGV0IGNvZGU7XG4gIGxldCBtZXNzYWdlO1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29kZSA9IChfYjIgPSAoX2EyID0gZGF0YS5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb2RlKSAhPSBudWxsID8gX2IyIDogXCJ1bmtub3duX2Vycm9yXCI7XG4gICAgbWVzc2FnZSA9IChfYyA9IGRhdGEuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYy5tZXNzYWdlO1xuICB9IGNhdGNoIHtcbiAgICBjb2RlID0gXCJ1bmtub3duX2Vycm9yXCI7XG4gIH1cbiAgbGV0IGVycm9yO1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIFwic3RvcmVfc3VzcGVuZGVkXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iU3RvcmVTdXNwZW5kZWRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZvcmJpZGRlblwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkFjY2Vzc0Vycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibm90X2ZvdW5kXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iTm90Rm91bmRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0b3JlX25vdF9mb3VuZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlN0b3JlTm90Rm91bmRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJhZF9yZXF1ZXN0XCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iRXJyb3IobWVzc2FnZSAhPSBudWxsID8gbWVzc2FnZSA6IFwiQmFkIHJlcXVlc3RcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic2VydmljZV91bmF2YWlsYWJsZVwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyYXRlX2xpbWl0ZWRcIjpcbiAgICAgIGVycm9yID0gY3JlYXRlQmxvYlNlcnZpY2VSYXRlTGltaXRlZChyZXNwb25zZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidW5rbm93bl9lcnJvclwiOlxuICAgIGNhc2UgXCJub3RfYWxsb3dlZFwiOlxuICAgIGRlZmF1bHQ6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iVW5rbm93bkVycm9yKCk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4geyBjb2RlLCBlcnJvciB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEFwaShwYXRobmFtZSwgaW5pdCwgY29tbWFuZE9wdGlvbnMpIHtcbiAgY29uc3QgYXBpVmVyc2lvbiA9IGdldEFwaVZlcnNpb24oKTtcbiAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYoY29tbWFuZE9wdGlvbnMpO1xuICBjb25zdCBhcGlSZXNwb25zZSA9IGF3YWl0IHJldHJ5KFxuICAgIGFzeW5jIChiYWlsKSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChnZXRBcGlVcmwocGF0aG5hbWUpLCB7XG4gICAgICAgIC4uLmluaXQsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIngtYXBpLXZlcnNpb25cIjogYXBpVmVyc2lvbixcbiAgICAgICAgICBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAuLi5pbml0LmhlYWRlcnNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGNvZGUsIGVycm9yIH0gPSBhd2FpdCBnZXRCbG9iRXJyb3IocmVzKTtcbiAgICAgIGlmIChjb2RlID09PSBcInVua25vd25fZXJyb3JcIiB8fCBjb2RlID09PSBcInNlcnZpY2VfdW5hdmFpbGFibGVcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGJhaWwoZXJyb3IpO1xuICAgIH0sXG4gICAge1xuICAgICAgcmV0cmllczogZ2V0UmV0cmllcygpLFxuICAgICAgb25SZXRyeTogKGVycm9yKSA9PiB7XG4gICAgICAgIGRlYnVnKGByZXRyeWluZyBBUEkgcmVxdWVzdCB0byAke3BhdGhuYW1lfWAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgaWYgKCFhcGlSZXNwb25zZSkge1xuICAgIHRocm93IG5ldyBCbG9iVW5rbm93bkVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGFwaVJlc3BvbnNlLmpzb24oKTtcbn1cblxuLy8gc3JjL3B1dC1oZWxwZXJzLnRzXG52YXIgcHV0T3B0aW9uSGVhZGVyTWFwID0ge1xuICBjYWNoZUNvbnRyb2xNYXhBZ2U6IFwieC1jYWNoZS1jb250cm9sLW1heC1hZ2VcIixcbiAgYWRkUmFuZG9tU3VmZml4OiBcIngtYWRkLXJhbmRvbS1zdWZmaXhcIixcbiAgY29udGVudFR5cGU6IFwieC1jb250ZW50LXR5cGVcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJjb250ZW50VHlwZVwiKSAmJiBvcHRpb25zLmNvbnRlbnRUeXBlKSB7XG4gICAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuY29udGVudFR5cGVdID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgfVxuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJhZGRSYW5kb21TdWZmaXhcIikgJiYgb3B0aW9ucy5hZGRSYW5kb21TdWZmaXggIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbcHV0T3B0aW9uSGVhZGVyTWFwLmFkZFJhbmRvbVN1ZmZpeF0gPSBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCA/IFwiMVwiIDogXCIwXCI7XG4gIH1cbiAgaWYgKGFsbG93ZWRPcHRpb25zLmluY2x1ZGVzKFwiY2FjaGVDb250cm9sTWF4QWdlXCIpICYmIG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzW3B1dE9wdGlvbkhlYWRlck1hcC5jYWNoZUNvbnRyb2xNYXhBZ2VdID0gb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVB1dE9wdGlvbnMoe1xuICBwYXRobmFtZSxcbiAgb3B0aW9ucyxcbiAgZXh0cmFDaGVja3MsXG4gIGdldFRva2VuXG59KSB7XG4gIGlmICghcGF0aG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwicGF0aG5hbWUgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIm1pc3Npbmcgb3B0aW9ucywgc2VlIHVzYWdlXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLmFjY2VzcyAhPT0gXCJwdWJsaWNcIikge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoJ2FjY2VzcyBtdXN0IGJlIFwicHVibGljXCInKTtcbiAgfVxuICBpZiAoZXh0cmFDaGVja3MpIHtcbiAgICBleHRyYUNoZWNrcyhvcHRpb25zKTtcbiAgfVxuICBpZiAoZ2V0VG9rZW4pIHtcbiAgICBvcHRpb25zLnRva2VuID0gYXdhaXQgZ2V0VG9rZW4ocGF0aG5hbWUsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L2NvbXBsZXRlLnRzXG5mdW5jdGlvbiBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBwYXJ0cywgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gICAgICB1cGxvYWRJZDogb3B0aW9ucy51cGxvYWRJZCxcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBvcHRpb25zLFxuICAgICAgcGFydHNcbiAgICB9KTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkKHtcbiAgdXBsb2FkSWQsXG4gIGtleSxcbiAgcGF0aG5hbWUsXG4gIHBhcnRzLFxuICBoZWFkZXJzLFxuICBvcHRpb25zXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgICAgYC9tcHUvJHtwYXRobmFtZX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICBcIngtbXB1LWFjdGlvblwiOiBcImNvbXBsZXRlXCIsXG4gICAgICAgICAgXCJ4LW1wdS11cGxvYWQtaWRcIjogdXBsb2FkSWQsXG4gICAgICAgICAgLy8ga2V5IGNhbiBiZSBhbnkgdXRmOCBjaGFyYWN0ZXIgc28gd2UgbmVlZCB0byBlbmNvZGUgaXQgYXMgSFRUUCBoZWFkZXJzIGNhbiBvbmx5IGJlIHVzLWFzY2lpXG4gICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzAjc3dlY3Rpb24tMy4yLjRcbiAgICAgICAgICBcIngtbXB1LWtleVwiOiBlbmNvZGVVUkkoa2V5KVxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJ0cylcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBkZWJ1ZyhcIm1wdTogY29tcGxldGVcIiwgcmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgKGVycm9yLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL211bHRpcGFydC9jcmVhdGUudHNcbmZ1bmN0aW9uIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBvcHRpb25zSW5wdXQpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgY3JlYXRlUHV0T3B0aW9ucyh7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWQoXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWRcbiAgICB9O1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKHBhdGhuYW1lLCBoZWFkZXJzLCBvcHRpb25zKSB7XG4gIGRlYnVnKFwibXB1OiBjcmVhdGVcIiwgXCJwYXRobmFtZTpcIiwgcGF0aG5hbWUpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICAgIGAvbXB1LyR7cGF0aG5hbWV9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgXCJ4LW1wdS1hY3Rpb25cIjogXCJjcmVhdGVcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgZGVidWcoXCJtcHU6IGNyZWF0ZVwiLCByZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyb3IubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L3VwbG9hZC50c1xuaW1wb3J0IGJ5dGVzIGZyb20gXCJieXRlc1wiO1xuZnVuY3Rpb24gY3JlYXRlVXBsb2FkUGFydE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBib2R5LCBvcHRpb25zSW5wdXQpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgY3JlYXRlUHV0T3B0aW9ucyh7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICB1cGxvYWRJZDogb3B0aW9ucy51cGxvYWRJZCxcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBwYXRobmFtZSxcbiAgICAgIHBhcnQ6IHsgYmxvYjogYm9keSwgcGFydE51bWJlcjogb3B0aW9ucy5wYXJ0TnVtYmVyIH0sXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGFib3J0Q29udHJvbGxlcjogb3B0aW9ucy5hYm9ydENvbnRyb2xsZXJcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZXRhZzogcmVzdWx0LmV0YWcsXG4gICAgICBwYXJ0TnVtYmVyOiBvcHRpb25zLnBhcnROdW1iZXJcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gdXBsb2FkUGFydCh7XG4gIHVwbG9hZElkLFxuICBrZXksXG4gIHBhdGhuYW1lLFxuICBoZWFkZXJzLFxuICBvcHRpb25zLFxuICBhYm9ydENvbnRyb2xsZXIsXG4gIHBhcnRcbn0pIHtcbiAgcmV0dXJuIHJlcXVlc3RBcGkoXG4gICAgYC9tcHUvJHtwYXRobmFtZX1gLFxuICAgIHtcbiAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgXCJ4LW1wdS1hY3Rpb25cIjogXCJ1cGxvYWRcIixcbiAgICAgICAgXCJ4LW1wdS1rZXlcIjogZW5jb2RlVVJJKGtleSksXG4gICAgICAgIFwieC1tcHUtdXBsb2FkLWlkXCI6IHVwbG9hZElkLFxuICAgICAgICBcIngtbXB1LXBhcnQtbnVtYmVyXCI6IHBhcnQucGFydE51bWJlci50b1N0cmluZygpXG4gICAgICB9LFxuICAgICAgLy8gd2VpcmQgdGhpbmdzIGJldHdlZW4gdW5kaWNpIHR5cGVzIGFuZCBuYXRpdmUgZmV0Y2ggdHlwZXNcbiAgICAgIGJvZHk6IHBhcnQuYmxvYixcbiAgICAgIC8vIHJlcXVpcmVkIGluIG9yZGVyIHRvIHN0cmVhbSBzb21lIGJvZHkgdHlwZXMgdG8gQ2xvdWRmbGFyZVxuICAgICAgLy8gY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIE5vZGUuanMsIHdlIG1heSBoYXZlIHRvIGZlYXR1cmUgZGV0ZWN0IHRoaXNcbiAgICAgIGR1cGxleDogXCJoYWxmXCJcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbnZhciBtYXhDb25jdXJyZW50VXBsb2FkcyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyA2IDogODtcbnZhciBwYXJ0U2l6ZUluQnl0ZXMgPSA4ICogMTAyNCAqIDEwMjQ7XG52YXIgbWF4Qnl0ZXNJbk1lbW9yeSA9IG1heENvbmN1cnJlbnRVcGxvYWRzICogcGFydFNpemVJbkJ5dGVzICogMjtcbmZ1bmN0aW9uIHVwbG9hZEFsbFBhcnRzKHtcbiAgdXBsb2FkSWQsXG4gIGtleSxcbiAgcGF0aG5hbWUsXG4gIHN0cmVhbSxcbiAgaGVhZGVycyxcbiAgb3B0aW9uc1xufSkge1xuICBkZWJ1ZyhcIm1wdTogdXBsb2FkIGluaXRcIiwgXCJrZXk6XCIsIGtleSk7XG4gIGNvbnN0IGludGVybmFsQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHBhcnRzVG9VcGxvYWQgPSBbXTtcbiAgICBjb25zdCBjb21wbGV0ZWRQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgYWN0aXZlVXBsb2FkcyA9IDA7XG4gICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgY3VycmVudFBhcnROdW1iZXIgPSAxO1xuICAgIGxldCByZWplY3RlZCA9IGZhbHNlO1xuICAgIGxldCBjdXJyZW50Qnl0ZXNJbk1lbW9yeSA9IDA7XG4gICAgbGV0IGRvbmVSZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IGJ5dGVzU2VudCA9IDA7XG4gICAgbGV0IGFycmF5QnVmZmVycyA9IFtdO1xuICAgIGxldCBjdXJyZW50UGFydEJ5dGVzUmVhZCA9IDA7XG4gICAgcmVhZCgpLmNhdGNoKGNhbmNlbCk7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgIGRlYnVnKFxuICAgICAgICBcIm1wdTogdXBsb2FkIHJlYWQgc3RhcnRcIixcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzOlwiLFxuICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICBcImN1cnJlbnRCeXRlc0luTWVtb3J5OlwiLFxuICAgICAgICBgJHtieXRlcyhjdXJyZW50Qnl0ZXNJbk1lbW9yeSl9LyR7Ynl0ZXMobWF4Qnl0ZXNJbk1lbW9yeSl9YCxcbiAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgIGJ5dGVzKGJ5dGVzU2VudClcbiAgICAgICk7XG4gICAgICByZWFkaW5nID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChjdXJyZW50Qnl0ZXNJbk1lbW9yeSA8IG1heEJ5dGVzSW5NZW1vcnkgJiYgIXJlamVjdGVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgZG9uZVJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgZGVidWcoXCJtcHU6IHVwbG9hZCByZWFkIGNvbnN1bWVkIHRoZSB3aG9sZSBzdHJlYW1cIik7XG4gICAgICAgICAgICBpZiAoYXJyYXlCdWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcGFydHNUb1VwbG9hZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXJ0TnVtYmVyOiBjdXJyZW50UGFydE51bWJlcisrLFxuICAgICAgICAgICAgICAgIGJsb2I6IG5ldyBCbG9iKGFycmF5QnVmZmVycywge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZW5kUGFydHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudEJ5dGVzSW5NZW1vcnkgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBsZXQgdmFsdWVPZmZzZXQgPSAwO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZU9mZnNldCA8IHZhbHVlLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1BhcnRTaXplID0gcGFydFNpemVJbkJ5dGVzIC0gY3VycmVudFBhcnRCeXRlc1JlYWQ7XG4gICAgICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgdmFsdWVPZmZzZXQgKyByZW1haW5pbmdQYXJ0U2l6ZSxcbiAgICAgICAgICAgICAgdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdmFsdWUuc2xpY2UodmFsdWVPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICBhcnJheUJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgICAgICBjdXJyZW50UGFydEJ5dGVzUmVhZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWVPZmZzZXQgPSBlbmRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcnRCeXRlc1JlYWQgPT09IHBhcnRTaXplSW5CeXRlcykge1xuICAgICAgICAgICAgICBwYXJ0c1RvVXBsb2FkLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhcnROdW1iZXI6IGN1cnJlbnRQYXJ0TnVtYmVyKyssXG4gICAgICAgICAgICAgICAgYmxvYjogbmV3IEJsb2IoYXJyYXlCdWZmZXJzLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFycmF5QnVmZmVycyA9IFtdO1xuICAgICAgICAgICAgICBjdXJyZW50UGFydEJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgICAgIHNlbmRQYXJ0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYW5jZWwoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJtcHU6IHVwbG9hZCByZWFkIGVuZFwiLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHM6XCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgKTtcbiAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2VuZFBhcnQocGFydCkge1xuICAgICAgYWN0aXZlVXBsb2FkcysrO1xuICAgICAgZGVidWcoXG4gICAgICAgIFwibXB1OiB1cGxvYWQgc2VuZCBwYXJ0IHN0YXJ0XCIsXG4gICAgICAgIFwicGFydE51bWJlcjpcIixcbiAgICAgICAgcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICBcInNpemU6XCIsXG4gICAgICAgIHBhcnQuYmxvYi5zaXplLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHM6XCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRlZFBhcnQgPSBhd2FpdCB1cGxvYWRQYXJ0KHtcbiAgICAgICAgICB1cGxvYWRJZCxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGFib3J0Q29udHJvbGxlcjogaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIsXG4gICAgICAgICAgcGFydFxuICAgICAgICB9KTtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgXCJtcHU6IHVwbG9hZCBzZW5kIHBhcnQgZW5kXCIsXG4gICAgICAgICAgXCJwYXJ0TnVtYmVyOlwiLFxuICAgICAgICAgIHBhcnQucGFydE51bWJlcixcbiAgICAgICAgICBcImFjdGl2ZVVwbG9hZHNcIixcbiAgICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgICAgYCR7Ynl0ZXMoY3VycmVudEJ5dGVzSW5NZW1vcnkpfS8ke2J5dGVzKG1heEJ5dGVzSW5NZW1vcnkpfWAsXG4gICAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgICApO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29tcGxldGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgcGFydE51bWJlcjogcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICAgIGV0YWc6IGNvbXBsZXRlZFBhcnQuZXRhZ1xuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudEJ5dGVzSW5NZW1vcnkgLT0gcGFydC5ibG9iLnNpemU7XG4gICAgICAgIGFjdGl2ZVVwbG9hZHMtLTtcbiAgICAgICAgYnl0ZXNTZW50ICs9IHBhcnQuYmxvYi5zaXplO1xuICAgICAgICBpZiAocGFydHNUb1VwbG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2VuZFBhcnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbmVSZWFkaW5nKSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZVVwbG9hZHMgPT09IDApIHtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgcmVzb2x2ZShjb21wbGV0ZWRQYXJ0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlYWRpbmcpIHtcbiAgICAgICAgICByZWFkKCkuY2F0Y2goY2FuY2VsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FuY2VsKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2VuZFBhcnRzKCkge1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlYnVnKFxuICAgICAgICBcInNlbmQgcGFydHNcIixcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzXCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwicGFydHNUb1VwbG9hZFwiLFxuICAgICAgICBwYXJ0c1RvVXBsb2FkLmxlbmd0aFxuICAgICAgKTtcbiAgICAgIHdoaWxlIChhY3RpdmVVcGxvYWRzIDwgbWF4Q29uY3VycmVudFVwbG9hZHMgJiYgcGFydHNUb1VwbG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcnRUb1NlbmQgPSBwYXJ0c1RvVXBsb2FkLnNoaWZ0KCk7XG4gICAgICAgIGlmIChwYXJ0VG9TZW5kKSB7XG4gICAgICAgICAgdm9pZCBzZW5kUGFydChwYXJ0VG9TZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWwoZXJyb3IpIHtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICBpbnRlcm5hbEFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgKGVycm9yLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL211bHRpcGFydC9oZWxwZXJzLnRzXG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gXCJzdHJlYW1cIjtcbmltcG9ydCBpc0J1ZmZlciBmcm9tIFwiaXMtYnVmZmVyXCI7XG5mdW5jdGlvbiB0b1JlYWRhYmxlU3RyZWFtKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gdmFsdWUuc3RyZWFtKCk7XG4gIH1cbiAgaWYgKGlzTm9kZUpzUmVhZGFibGVTdHJlYW0odmFsdWUpKSB7XG4gICAgcmV0dXJuIFJlYWRhYmxlLnRvV2ViKHZhbHVlKTtcbiAgfVxuICBsZXQgc3RyZWFtVmFsdWU7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgc3RyZWFtVmFsdWUgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc05vZGVKc0J1ZmZlck9yU3RyaW5nKHZhbHVlKSkge1xuICAgIHN0cmVhbVZhbHVlID0gdmFsdWUuYnVmZmVyO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbVZhbHVlID0gc3RyaW5nVG9VaW50OEFycmF5KHZhbHVlKTtcbiAgfVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoc3RyZWFtVmFsdWUpO1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc05vZGVKc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnBpcGUgPT09IFwiZnVuY3Rpb25cIiAmJiB2YWx1ZS5yZWFkYWJsZSAmJiB0eXBlb2YgdmFsdWUuX3JlYWQgPT09IFwiZnVuY3Rpb25cIiAmJiAvLyBAdHMtZXhwZWN0LWVycm9yIF9yZWFkYWJsZVN0YXRlIGRvZXMgZXhpc3RzIG9uIFJlYWRhYmxlXG4gIHR5cGVvZiB2YWx1ZS5fcmVhZGFibGVTdGF0ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvVWludDhBcnJheShzKSB7XG4gIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICByZXR1cm4gZW5jLmVuY29kZShzKTtcbn1cbmZ1bmN0aW9uIGlzTm9kZUpzQnVmZmVyT3JTdHJpbmcoaW5wdXQpIHtcbiAgcmV0dXJuIGlzQnVmZmVyKGlucHV0KTtcbn1cblxuLy8gc3JjL211bHRpcGFydC91bmNvbnRyb2xsZWQudHNcbmFzeW5jIGZ1bmN0aW9uIHVuY29udHJvbGxlZE11bHRpcGFydFVwbG9hZChwYXRobmFtZSwgYm9keSwgaGVhZGVycywgb3B0aW9ucykge1xuICBkZWJ1ZyhcIm1wdTogaW5pdFwiLCBcInBhdGhuYW1lOlwiLCBwYXRobmFtZSwgXCJoZWFkZXJzOlwiLCBoZWFkZXJzKTtcbiAgY29uc3Qgc3RyZWFtID0gdG9SZWFkYWJsZVN0cmVhbShib2R5KTtcbiAgY29uc3QgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWQoXG4gICAgcGF0aG5hbWUsXG4gICAgaGVhZGVycyxcbiAgICBvcHRpb25zXG4gICk7XG4gIGNvbnN0IHBhcnRzID0gYXdhaXQgdXBsb2FkQWxsUGFydHMoe1xuICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICBwYXRobmFtZSxcbiAgICBzdHJlYW0sXG4gICAgaGVhZGVycyxcbiAgICBvcHRpb25zXG4gIH0pO1xuICBjb25zdCBibG9iID0gYXdhaXQgY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoe1xuICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJ0cyxcbiAgICBoZWFkZXJzLFxuICAgIG9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiBibG9iO1xufVxuXG4vLyBzcmMvcHV0LnRzXG5mdW5jdGlvbiBjcmVhdGVQdXRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9ucyxcbiAgZ2V0VG9rZW4sXG4gIGV4dHJhQ2hlY2tzXG59KSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBwdXQocGF0aG5hbWUsIGJvZHlPck9wdGlvbnMsIG9wdGlvbnNJbnB1dCkge1xuICAgIGNvbnN0IGlzRm9sZGVyQ3JlYXRpb24gPSBwYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gICAgaWYgKCFib2R5T3JPcHRpb25zICYmICFpc0ZvbGRlckNyZWF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiYm9keSBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKGJvZHlPck9wdGlvbnMgJiYgb3B0aW9uc0lucHV0ICYmIGlzRm9sZGVyQ3JlYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJib2R5IGlzIG5vdCBhbGxvd2VkIGZvciBjcmVhdGluZyBlbXB0eSBmb2xkZXJzXCIpO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gaXNGb2xkZXJDcmVhdGlvbiA/IHZvaWQgMCA6IGJvZHlPck9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICAvLyB3aGVuIG5vIGJvZHkgaXMgcmVxdWlyZWQgKGZvciBmb2xkZXIgY3JlYXRpb25zKSBvcHRpb25zIGFyZSB0aGUgc2Vjb25kIGFyZ3VtZW50XG4gICAgICBvcHRpb25zOiBpc0ZvbGRlckNyZWF0aW9uID8gYm9keU9yT3B0aW9ucyA6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMubXVsdGlwYXJ0ID09PSB0cnVlICYmIGJvZHkpIHtcbiAgICAgIHJldHVybiB1bmNvbnRyb2xsZWRNdWx0aXBhcnRVcGxvYWQocGF0aG5hbWUsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgICBgLyR7cGF0aG5hbWV9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBib2R5LFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICAvLyByZXF1aXJlZCBpbiBvcmRlciB0byBzdHJlYW0gc29tZSBib2R5IHR5cGVzIHRvIENsb3VkZmxhcmVcbiAgICAgICAgLy8gY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIE5vZGUuanMsIHdlIG1heSBoYXZlIHRvIGZlYXR1cmUgZGV0ZWN0IHRoaXNcbiAgICAgICAgZHVwbGV4OiBcImhhbGZcIlxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgIGRvd25sb2FkVXJsOiByZXNwb25zZS5kb3dubG9hZFVybCxcbiAgICAgIHBhdGhuYW1lOiByZXNwb25zZS5wYXRobmFtZSxcbiAgICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5jb250ZW50VHlwZSxcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogcmVzcG9uc2UuY29udGVudERpc3Bvc2l0aW9uXG4gICAgfTtcbiAgfTtcbn1cblxuLy8gc3JjL211bHRpcGFydC9jcmVhdGUtdXBsb2FkZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZGVyTWV0aG9kKHsgYWxsb3dlZE9wdGlvbnMsIGdldFRva2VuLCBleHRyYUNoZWNrcyB9KSB7XG4gIHJldHVybiBhc3luYyAocGF0aG5hbWUsIG9wdGlvbnNJbnB1dCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZU11bHRpcGFydFVwbG9hZChcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICAgIGFzeW5jIHVwbG9hZFBhcnQocGFydE51bWJlciwgYm9keSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGxvYWRQYXJ0KHtcbiAgICAgICAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWQsXG4gICAgICAgICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgcGFydDogeyBwYXJ0TnVtYmVyLCBibG9iOiBib2R5IH0sXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV0YWc6IHJlc3VsdC5ldGFnLFxuICAgICAgICAgIHBhcnROdW1iZXJcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBjb21wbGV0ZShwYXJ0cykge1xuICAgICAgICByZXR1cm4gY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoe1xuICAgICAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICAgICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IHtcbiAgZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52LFxuICBCbG9iRXJyb3IsXG4gIGdldERvd25sb2FkVXJsLFxuICBCbG9iQWNjZXNzRXJyb3IsXG4gIEJsb2JTdG9yZU5vdEZvdW5kRXJyb3IsXG4gIEJsb2JTdG9yZVN1c3BlbmRlZEVycm9yLFxuICBCbG9iVW5rbm93bkVycm9yLFxuICBCbG9iTm90Rm91bmRFcnJvcixcbiAgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUsXG4gIHJlcXVlc3RBcGksXG4gIGNyZWF0ZUNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kLFxuICBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZVVwbG9hZFBhcnRNZXRob2QsXG4gIGNyZWF0ZVB1dE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1JREtDWTRTMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/chunk-IDKCY4S2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/client.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/client.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   completeMultipartUpload: () => (/* binding */ completeMultipartUpload),\n/* harmony export */   createMultipartUpload: () => (/* binding */ createMultipartUpload),\n/* harmony export */   createMultipartUploader: () => (/* binding */ createMultipartUploader),\n/* harmony export */   generateClientTokenFromReadWriteToken: () => (/* binding */ generateClientTokenFromReadWriteToken),\n/* harmony export */   getPayloadFromClientToken: () => (/* binding */ getPayloadFromClientToken),\n/* harmony export */   handleUpload: () => (/* binding */ handleUpload),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   upload: () => (/* binding */ upload),\n/* harmony export */   uploadPart: () => (/* binding */ uploadPart)\n/* harmony export */ });\n/* harmony import */ var _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-IDKCY4S2.js */ \"(ssr)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/chunk-IDKCY4S2.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! undici */ \"(ssr)/./node_modules/.pnpm/undici@5.29.0/node_modules/undici/index.js\");\n\n\n// src/client.ts\n\n\nfunction createPutExtraChecks(methodName) {\n  return function extraChecks(options) {\n    if (typeof window === \"undefined\") {\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        `${methodName} must be called from a client environment`\n      );\n    }\n    if (!options.token.startsWith(\"vercel_blob_client_\")) {\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(`${methodName} must be called with a client token`);\n    }\n    if (\n      // @ts-expect-error -- Runtime check for DX.\n      options.addRandomSuffix !== void 0 || // @ts-expect-error -- Runtime check for DX.\n      options.cacheControlMaxAge !== void 0\n    ) {\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        `${methodName} doesn't allow addRandomSuffix and cacheControlMaxAge. Configure these options at the server side when generating client tokens.`\n      );\n    }\n  };\n}\nvar put = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.createPutMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks: createPutExtraChecks(\"client/`put`\")\n});\nvar createMultipartUpload = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.createCreateMultipartUploadMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks: createPutExtraChecks(\"client/`createMultipartUpload`\")\n});\nvar createMultipartUploader = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.createCreateMultipartUploaderMethod)(\n  {\n    allowedOptions: [\"contentType\"],\n    extraChecks: createPutExtraChecks(\"client/`createMultipartUpload`\")\n  }\n);\nvar uploadPart = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.createUploadPartMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks: createPutExtraChecks(\"client/`multipartUpload`\")\n});\nvar completeMultipartUpload = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.createCompleteMultipartUploadMethod)(\n  {\n    allowedOptions: [\"contentType\"],\n    extraChecks: createPutExtraChecks(\"client/`completeMultipartUpload`\")\n  }\n);\nvar upload = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.createPutMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks(options) {\n    if (typeof window === \"undefined\") {\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        \"client/`upload` must be called from a client environment\"\n      );\n    }\n    if (options.handleUploadUrl === void 0) {\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        \"client/`upload` requires the 'handleUploadUrl' parameter\"\n      );\n    }\n    if (\n      // @ts-expect-error -- Runtime check for DX.\n      options.addRandomSuffix !== void 0 || // @ts-expect-error -- Runtime check for DX.\n      options.cacheControlMaxAge !== void 0\n    ) {\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        \"client/`upload` doesn't allow addRandomSuffix and cacheControlMaxAge. Configure these options at the server side when generating client tokens.\"\n      );\n    }\n  },\n  async getToken(pathname, options) {\n    var _a, _b;\n    return retrieveClientToken({\n      handleUploadUrl: options.handleUploadUrl,\n      pathname,\n      clientPayload: (_a = options.clientPayload) != null ? _a : null,\n      multipart: (_b = options.multipart) != null ? _b : false\n    });\n  }\n});\nasync function importKey(token) {\n  return globalThis.crypto.subtle.importKey(\n    \"raw\",\n    new TextEncoder().encode(token),\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false,\n    [\"sign\", \"verify\"]\n  );\n}\nasync function signPayload(payload, token) {\n  if (!globalThis.crypto) {\n    return crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac(\"sha256\", token).update(payload).digest(\"hex\");\n  }\n  const signature = await globalThis.crypto.subtle.sign(\n    \"HMAC\",\n    await importKey(token),\n    new TextEncoder().encode(payload)\n  );\n  return Buffer.from(new Uint8Array(signature)).toString(\"hex\");\n}\nasync function verifyCallbackSignature({\n  token,\n  signature,\n  body\n}) {\n  const secret = token;\n  if (!globalThis.crypto) {\n    const digest = crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac(\"sha256\", secret).update(body).digest(\"hex\");\n    const digestBuffer = Buffer.from(digest);\n    const signatureBuffer = Buffer.from(signature);\n    return digestBuffer.length === signatureBuffer.length && crypto__WEBPACK_IMPORTED_MODULE_0__.timingSafeEqual(digestBuffer, signatureBuffer);\n  }\n  const verified = await globalThis.crypto.subtle.verify(\n    \"HMAC\",\n    await importKey(token),\n    hexToArrayByte(signature),\n    new TextEncoder().encode(body)\n  );\n  return verified;\n}\nfunction hexToArrayByte(input) {\n  if (input.length % 2 !== 0) {\n    throw new RangeError(\"Expected string to be an even number of characters\");\n  }\n  const view = new Uint8Array(input.length / 2);\n  for (let i = 0; i < input.length; i += 2) {\n    view[i / 2] = parseInt(input.substring(i, i + 2), 16);\n  }\n  return Buffer.from(view);\n}\nfunction getPayloadFromClientToken(clientToken) {\n  const [, , , , encodedToken] = clientToken.split(\"_\");\n  const encodedPayload = Buffer.from(encodedToken != null ? encodedToken : \"\", \"base64\").toString().split(\".\")[1];\n  const decodedPayload = Buffer.from(encodedPayload != null ? encodedPayload : \"\", \"base64\").toString();\n  return JSON.parse(decodedPayload);\n}\nvar EventTypes = {\n  generateClientToken: \"blob.generate-client-token\",\n  uploadCompleted: \"blob.upload-completed\"\n};\nasync function handleUpload({\n  token,\n  request,\n  body,\n  onBeforeGenerateToken,\n  onUploadCompleted\n}) {\n  var _a, _b, _c, _d;\n  const resolvedToken = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.getTokenFromOptionsOrEnv)({ token });\n  const type = body.type;\n  switch (type) {\n    case \"blob.generate-client-token\": {\n      const { pathname, callbackUrl, clientPayload, multipart } = body.payload;\n      const payload = await onBeforeGenerateToken(\n        pathname,\n        clientPayload,\n        multipart\n      );\n      const tokenPayload = (_a = payload.tokenPayload) != null ? _a : clientPayload;\n      const oneHourInSeconds = 60 * 60;\n      const now = /* @__PURE__ */ new Date();\n      const validUntil = (_b = payload.validUntil) != null ? _b : now.setSeconds(now.getSeconds() + oneHourInSeconds);\n      return {\n        type,\n        clientToken: await generateClientTokenFromReadWriteToken({\n          ...payload,\n          token: resolvedToken,\n          pathname,\n          onUploadCompleted: {\n            callbackUrl,\n            tokenPayload\n          },\n          validUntil\n        })\n      };\n    }\n    case \"blob.upload-completed\": {\n      const signatureHeader = \"x-vercel-signature\";\n      const signature = \"credentials\" in request ? (_c = request.headers.get(signatureHeader)) != null ? _c : \"\" : (_d = request.headers[signatureHeader]) != null ? _d : \"\";\n      if (!signature) {\n        throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Missing callback signature\");\n      }\n      const isVerified = await verifyCallbackSignature({\n        token: resolvedToken,\n        signature,\n        body: JSON.stringify(body)\n      });\n      if (!isVerified) {\n        throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Invalid callback signature\");\n      }\n      await onUploadCompleted(body.payload);\n      return { type, response: \"ok\" };\n    }\n    default:\n      throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Invalid event type\");\n  }\n}\nasync function retrieveClientToken(options) {\n  const { handleUploadUrl, pathname } = options;\n  const url = isAbsoluteUrl(handleUploadUrl) ? handleUploadUrl : toAbsoluteUrl(handleUploadUrl);\n  const event = {\n    type: EventTypes.generateClientToken,\n    payload: {\n      pathname,\n      callbackUrl: url,\n      clientPayload: options.clientPayload,\n      multipart: options.multipart\n    }\n  };\n  const res = await (0,undici__WEBPACK_IMPORTED_MODULE_1__.fetch)(url, {\n    method: \"POST\",\n    body: JSON.stringify(event),\n    headers: {\n      \"content-type\": \"application/json\"\n    }\n  });\n  if (!res.ok) {\n    throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Failed to  retrieve the client token\");\n  }\n  try {\n    const { clientToken } = await res.json();\n    return clientToken;\n  } catch (e) {\n    throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Failed to retrieve the client token\");\n  }\n}\nfunction toAbsoluteUrl(url) {\n  return new URL(url, window.location.href).href;\n}\nfunction isAbsoluteUrl(url) {\n  try {\n    return Boolean(new URL(url));\n  } catch (e) {\n    return false;\n  }\n}\nasync function generateClientTokenFromReadWriteToken({\n  token,\n  ...argsWithoutToken\n}) {\n  var _a;\n  if (typeof window !== \"undefined\") {\n    throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n      '\"generateClientTokenFromReadWriteToken\" must be called from a server environment'\n    );\n  }\n  const timestamp = /* @__PURE__ */ new Date();\n  timestamp.setSeconds(timestamp.getSeconds() + 30);\n  const readWriteToken = (0,_chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.getTokenFromOptionsOrEnv)({ token });\n  const [, , , storeId = null] = readWriteToken.split(\"_\");\n  if (!storeId) {\n    throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n      token ? \"Invalid `token` parameter\" : \"Invalid `BLOB_READ_WRITE_TOKEN`\"\n    );\n  }\n  const payload = Buffer.from(\n    JSON.stringify({\n      ...argsWithoutToken,\n      validUntil: (_a = argsWithoutToken.validUntil) != null ? _a : timestamp.getTime()\n    })\n  ).toString(\"base64\");\n  const securedKey = await signPayload(payload, readWriteToken);\n  if (!securedKey) {\n    throw new _chunk_IDKCY4S2_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Unable to sign client token\");\n  }\n  return `vercel_blob_client_${storeId}_${Buffer.from(\n    `${securedKey}.${payload}`\n  ).toString(\"base64\")}`;\n}\n\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZlcmNlbCtibG9iQDAuMjIuMy9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQVE2Qjs7QUFFN0I7QUFDaUM7QUFDRjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVM7QUFDekIsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBUyxJQUFJLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUVBQWU7QUFDekI7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEIscUZBQWlDO0FBQzdEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCLHVGQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBFQUFzQjtBQUN2QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4Qix1RkFBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwrQkFBK0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxtQkFBbUIsOENBQWlCO0FBQ3BDO0FBQ0E7QUFDQSw2REFBNkQsbURBQXNCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3QkFBd0IsNEVBQXdCLEdBQUcsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFrRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlEQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0IseURBQVM7QUFDM0I7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLHlEQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQSxJQUFJO0FBQ0osY0FBYyx5REFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsY0FBYyx5REFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRFQUF3QixHQUFHLE9BQU87QUFDM0Q7QUFDQTtBQUNBLGNBQWMseURBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBUztBQUN2QjtBQUNBLCtCQUErQixRQUFRLEdBQUc7QUFDMUMsT0FBTyxXQUFXLEdBQUcsUUFBUTtBQUM3Qix1QkFBdUI7QUFDdkI7QUFXRTtBQUNGIiwic291cmNlcyI6WyJDOlxccHJvamVjdHNcXGF1dGhcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEB2ZXJjZWwrYmxvYkAwLjIyLjNcXG5vZGVfbW9kdWxlc1xcQHZlcmNlbFxcYmxvYlxcZGlzdFxcY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJsb2JFcnJvcixcbiAgY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QsXG4gIGNyZWF0ZVB1dE1ldGhvZCxcbiAgY3JlYXRlVXBsb2FkUGFydE1ldGhvZCxcbiAgZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52XG59IGZyb20gXCIuL2NodW5rLUlES0NZNFMyLmpzXCI7XG5cbi8vIHNyYy9jbGllbnQudHNcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5pbXBvcnQgeyBmZXRjaCB9IGZyb20gXCJ1bmRpY2lcIjtcbmZ1bmN0aW9uIGNyZWF0ZVB1dEV4dHJhQ2hlY2tzKG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGV4dHJhQ2hlY2tzKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgYCR7bWV0aG9kTmFtZX0gbXVzdCBiZSBjYWxsZWQgZnJvbSBhIGNsaWVudCBlbnZpcm9ubWVudGBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy50b2tlbi5zdGFydHNXaXRoKFwidmVyY2VsX2Jsb2JfY2xpZW50X1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihgJHttZXRob2ROYW1lfSBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgY2xpZW50IHRva2VuYCk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUnVudGltZSBjaGVjayBmb3IgRFguXG4gICAgICBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCAhPT0gdm9pZCAwIHx8IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUnVudGltZSBjaGVjayBmb3IgRFguXG4gICAgICBvcHRpb25zLmNhY2hlQ29udHJvbE1heEFnZSAhPT0gdm9pZCAwXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBgJHttZXRob2ROYW1lfSBkb2Vzbid0IGFsbG93IGFkZFJhbmRvbVN1ZmZpeCBhbmQgY2FjaGVDb250cm9sTWF4QWdlLiBDb25maWd1cmUgdGhlc2Ugb3B0aW9ucyBhdCB0aGUgc2VydmVyIHNpZGUgd2hlbiBnZW5lcmF0aW5nIGNsaWVudCB0b2tlbnMuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG52YXIgcHV0ID0gY3JlYXRlUHV0TWV0aG9kKHtcbiAgYWxsb3dlZE9wdGlvbnM6IFtcImNvbnRlbnRUeXBlXCJdLFxuICBleHRyYUNoZWNrczogY3JlYXRlUHV0RXh0cmFDaGVja3MoXCJjbGllbnQvYHB1dGBcIilcbn0pO1xudmFyIGNyZWF0ZU11bHRpcGFydFVwbG9hZCA9IGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjb250ZW50VHlwZVwiXSxcbiAgZXh0cmFDaGVja3M6IGNyZWF0ZVB1dEV4dHJhQ2hlY2tzKFwiY2xpZW50L2BjcmVhdGVNdWx0aXBhcnRVcGxvYWRgXCIpXG59KTtcbnZhciBjcmVhdGVNdWx0aXBhcnRVcGxvYWRlciA9IGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZGVyTWV0aG9kKFxuICB7XG4gICAgYWxsb3dlZE9wdGlvbnM6IFtcImNvbnRlbnRUeXBlXCJdLFxuICAgIGV4dHJhQ2hlY2tzOiBjcmVhdGVQdXRFeHRyYUNoZWNrcyhcImNsaWVudC9gY3JlYXRlTXVsdGlwYXJ0VXBsb2FkYFwiKVxuICB9XG4pO1xudmFyIHVwbG9hZFBhcnQgPSBjcmVhdGVVcGxvYWRQYXJ0TWV0aG9kKHtcbiAgYWxsb3dlZE9wdGlvbnM6IFtcImNvbnRlbnRUeXBlXCJdLFxuICBleHRyYUNoZWNrczogY3JlYXRlUHV0RXh0cmFDaGVja3MoXCJjbGllbnQvYG11bHRpcGFydFVwbG9hZGBcIilcbn0pO1xudmFyIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkID0gY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QoXG4gIHtcbiAgICBhbGxvd2VkT3B0aW9uczogW1wiY29udGVudFR5cGVcIl0sXG4gICAgZXh0cmFDaGVja3M6IGNyZWF0ZVB1dEV4dHJhQ2hlY2tzKFwiY2xpZW50L2Bjb21wbGV0ZU11bHRpcGFydFVwbG9hZGBcIilcbiAgfVxuKTtcbnZhciB1cGxvYWQgPSBjcmVhdGVQdXRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY29udGVudFR5cGVcIl0sXG4gIGV4dHJhQ2hlY2tzKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgXCJjbGllbnQvYHVwbG9hZGAgbXVzdCBiZSBjYWxsZWQgZnJvbSBhIGNsaWVudCBlbnZpcm9ubWVudFwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVVcGxvYWRVcmwgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgXCJjbGllbnQvYHVwbG9hZGAgcmVxdWlyZXMgdGhlICdoYW5kbGVVcGxvYWRVcmwnIHBhcmFtZXRlclwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFJ1bnRpbWUgY2hlY2sgZm9yIERYLlxuICAgICAgb3B0aW9ucy5hZGRSYW5kb21TdWZmaXggIT09IHZvaWQgMCB8fCAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFJ1bnRpbWUgY2hlY2sgZm9yIERYLlxuICAgICAgb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UgIT09IHZvaWQgMFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgXCJjbGllbnQvYHVwbG9hZGAgZG9lc24ndCBhbGxvdyBhZGRSYW5kb21TdWZmaXggYW5kIGNhY2hlQ29udHJvbE1heEFnZS4gQ29uZmlndXJlIHRoZXNlIG9wdGlvbnMgYXQgdGhlIHNlcnZlciBzaWRlIHdoZW4gZ2VuZXJhdGluZyBjbGllbnQgdG9rZW5zLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAgYXN5bmMgZ2V0VG9rZW4ocGF0aG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiByZXRyaWV2ZUNsaWVudFRva2VuKHtcbiAgICAgIGhhbmRsZVVwbG9hZFVybDogb3B0aW9ucy5oYW5kbGVVcGxvYWRVcmwsXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGNsaWVudFBheWxvYWQ6IChfYSA9IG9wdGlvbnMuY2xpZW50UGF5bG9hZCkgIT0gbnVsbCA/IF9hIDogbnVsbCxcbiAgICAgIG11bHRpcGFydDogKF9iID0gb3B0aW9ucy5tdWx0aXBhcnQpICE9IG51bGwgPyBfYiA6IGZhbHNlXG4gICAgfSk7XG4gIH1cbn0pO1xuYXN5bmMgZnVuY3Rpb24gaW1wb3J0S2V5KHRva2VuKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgIFwicmF3XCIsXG4gICAgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRva2VuKSxcbiAgICB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBcIlNIQS0yNTZcIiB9LFxuICAgIGZhbHNlLFxuICAgIFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl1cbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25QYXlsb2FkKHBheWxvYWQsIHRva2VuKSB7XG4gIGlmICghZ2xvYmFsVGhpcy5jcnlwdG8pIHtcbiAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgdG9rZW4pLnVwZGF0ZShwYXlsb2FkKS5kaWdlc3QoXCJoZXhcIik7XG4gIH1cbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlLnNpZ24oXG4gICAgXCJITUFDXCIsXG4gICAgYXdhaXQgaW1wb3J0S2V5KHRva2VuKSxcbiAgICBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGF5bG9hZClcbiAgKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkpLnRvU3RyaW5nKFwiaGV4XCIpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5Q2FsbGJhY2tTaWduYXR1cmUoe1xuICB0b2tlbixcbiAgc2lnbmF0dXJlLFxuICBib2R5XG59KSB7XG4gIGNvbnN0IHNlY3JldCA9IHRva2VuO1xuICBpZiAoIWdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgY29uc3QgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgc2VjcmV0KS51cGRhdGUoYm9keSkuZGlnZXN0KFwiaGV4XCIpO1xuICAgIGNvbnN0IGRpZ2VzdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRpZ2VzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gZGlnZXN0QnVmZmVyLmxlbmd0aCA9PT0gc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCAmJiBjcnlwdG8udGltaW5nU2FmZUVxdWFsKGRpZ2VzdEJ1ZmZlciwgc2lnbmF0dXJlQnVmZmVyKTtcbiAgfVxuICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS52ZXJpZnkoXG4gICAgXCJITUFDXCIsXG4gICAgYXdhaXQgaW1wb3J0S2V5KHRva2VuKSxcbiAgICBoZXhUb0FycmF5Qnl0ZShzaWduYXR1cmUpLFxuICAgIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShib2R5KVxuICApO1xuICByZXR1cm4gdmVyaWZpZWQ7XG59XG5mdW5jdGlvbiBoZXhUb0FycmF5Qnl0ZShpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIHRvIGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGNoYXJhY3RlcnNcIik7XG4gIH1cbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCAvIDIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmlld1tpIC8gMl0gPSBwYXJzZUludChpbnB1dC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNik7XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZpZXcpO1xufVxuZnVuY3Rpb24gZ2V0UGF5bG9hZEZyb21DbGllbnRUb2tlbihjbGllbnRUb2tlbikge1xuICBjb25zdCBbLCAsICwgLCBlbmNvZGVkVG9rZW5dID0gY2xpZW50VG9rZW4uc3BsaXQoXCJfXCIpO1xuICBjb25zdCBlbmNvZGVkUGF5bG9hZCA9IEJ1ZmZlci5mcm9tKGVuY29kZWRUb2tlbiAhPSBudWxsID8gZW5jb2RlZFRva2VuIDogXCJcIiwgXCJiYXNlNjRcIikudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV07XG4gIGNvbnN0IGRlY29kZWRQYXlsb2FkID0gQnVmZmVyLmZyb20oZW5jb2RlZFBheWxvYWQgIT0gbnVsbCA/IGVuY29kZWRQYXlsb2FkIDogXCJcIiwgXCJiYXNlNjRcIikudG9TdHJpbmcoKTtcbiAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZFBheWxvYWQpO1xufVxudmFyIEV2ZW50VHlwZXMgPSB7XG4gIGdlbmVyYXRlQ2xpZW50VG9rZW46IFwiYmxvYi5nZW5lcmF0ZS1jbGllbnQtdG9rZW5cIixcbiAgdXBsb2FkQ29tcGxldGVkOiBcImJsb2IudXBsb2FkLWNvbXBsZXRlZFwiXG59O1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlVXBsb2FkKHtcbiAgdG9rZW4sXG4gIHJlcXVlc3QsXG4gIGJvZHksXG4gIG9uQmVmb3JlR2VuZXJhdGVUb2tlbixcbiAgb25VcGxvYWRDb21wbGV0ZWRcbn0pIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICBjb25zdCByZXNvbHZlZFRva2VuID0gZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52KHsgdG9rZW4gfSk7XG4gIGNvbnN0IHR5cGUgPSBib2R5LnR5cGU7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJibG9iLmdlbmVyYXRlLWNsaWVudC10b2tlblwiOiB7XG4gICAgICBjb25zdCB7IHBhdGhuYW1lLCBjYWxsYmFja1VybCwgY2xpZW50UGF5bG9hZCwgbXVsdGlwYXJ0IH0gPSBib2R5LnBheWxvYWQ7XG4gICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgb25CZWZvcmVHZW5lcmF0ZVRva2VuKFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgY2xpZW50UGF5bG9hZCxcbiAgICAgICAgbXVsdGlwYXJ0XG4gICAgICApO1xuICAgICAgY29uc3QgdG9rZW5QYXlsb2FkID0gKF9hID0gcGF5bG9hZC50b2tlblBheWxvYWQpICE9IG51bGwgPyBfYSA6IGNsaWVudFBheWxvYWQ7XG4gICAgICBjb25zdCBvbmVIb3VySW5TZWNvbmRzID0gNjAgKiA2MDtcbiAgICAgIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgdmFsaWRVbnRpbCA9IChfYiA9IHBheWxvYWQudmFsaWRVbnRpbCkgIT0gbnVsbCA/IF9iIDogbm93LnNldFNlY29uZHMobm93LmdldFNlY29uZHMoKSArIG9uZUhvdXJJblNlY29uZHMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2xpZW50VG9rZW46IGF3YWl0IGdlbmVyYXRlQ2xpZW50VG9rZW5Gcm9tUmVhZFdyaXRlVG9rZW4oe1xuICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgdG9rZW46IHJlc29sdmVkVG9rZW4sXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgb25VcGxvYWRDb21wbGV0ZWQ6IHtcbiAgICAgICAgICAgIGNhbGxiYWNrVXJsLFxuICAgICAgICAgICAgdG9rZW5QYXlsb2FkXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2YWxpZFVudGlsXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiYmxvYi51cGxvYWQtY29tcGxldGVkXCI6IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUhlYWRlciA9IFwieC12ZXJjZWwtc2lnbmF0dXJlXCI7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBcImNyZWRlbnRpYWxzXCIgaW4gcmVxdWVzdCA/IChfYyA9IHJlcXVlc3QuaGVhZGVycy5nZXQoc2lnbmF0dXJlSGVhZGVyKSkgIT0gbnVsbCA/IF9jIDogXCJcIiA6IChfZCA9IHJlcXVlc3QuaGVhZGVyc1tzaWduYXR1cmVIZWFkZXJdKSAhPSBudWxsID8gX2QgOiBcIlwiO1xuICAgICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIk1pc3NpbmcgY2FsbGJhY2sgc2lnbmF0dXJlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IHZlcmlmeUNhbGxiYWNrU2lnbmF0dXJlKHtcbiAgICAgICAgdG9rZW46IHJlc29sdmVkVG9rZW4sXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc1ZlcmlmaWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJJbnZhbGlkIGNhbGxiYWNrIHNpZ25hdHVyZVwiKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG9uVXBsb2FkQ29tcGxldGVkKGJvZHkucGF5bG9hZCk7XG4gICAgICByZXR1cm4geyB0eXBlLCByZXNwb25zZTogXCJva1wiIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiSW52YWxpZCBldmVudCB0eXBlXCIpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZXRyaWV2ZUNsaWVudFRva2VuKG9wdGlvbnMpIHtcbiAgY29uc3QgeyBoYW5kbGVVcGxvYWRVcmwsIHBhdGhuYW1lIH0gPSBvcHRpb25zO1xuICBjb25zdCB1cmwgPSBpc0Fic29sdXRlVXJsKGhhbmRsZVVwbG9hZFVybCkgPyBoYW5kbGVVcGxvYWRVcmwgOiB0b0Fic29sdXRlVXJsKGhhbmRsZVVwbG9hZFVybCk7XG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIHR5cGU6IEV2ZW50VHlwZXMuZ2VuZXJhdGVDbGllbnRUb2tlbixcbiAgICBwYXlsb2FkOiB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIGNhbGxiYWNrVXJsOiB1cmwsXG4gICAgICBjbGllbnRQYXlsb2FkOiBvcHRpb25zLmNsaWVudFBheWxvYWQsXG4gICAgICBtdWx0aXBhcnQ6IG9wdGlvbnMubXVsdGlwYXJ0XG4gICAgfVxuICB9O1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGV2ZW50KSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH1cbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIkZhaWxlZCB0byAgcmV0cmlldmUgdGhlIGNsaWVudCB0b2tlblwiKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHsgY2xpZW50VG9rZW4gfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIGNsaWVudFRva2VuO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIkZhaWxlZCB0byByZXRyaWV2ZSB0aGUgY2xpZW50IHRva2VuXCIpO1xuICB9XG59XG5mdW5jdGlvbiB0b0Fic29sdXRlVXJsKHVybCkge1xuICByZXR1cm4gbmV3IFVSTCh1cmwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5ocmVmO1xufVxuZnVuY3Rpb24gaXNBYnNvbHV0ZVVybCh1cmwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gQm9vbGVhbihuZXcgVVJMKHVybCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuKHtcbiAgdG9rZW4sXG4gIC4uLmFyZ3NXaXRob3V0VG9rZW5cbn0pIHtcbiAgdmFyIF9hO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAnXCJnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuXCIgbXVzdCBiZSBjYWxsZWQgZnJvbSBhIHNlcnZlciBlbnZpcm9ubWVudCdcbiAgICApO1xuICB9XG4gIGNvbnN0IHRpbWVzdGFtcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICB0aW1lc3RhbXAuc2V0U2Vjb25kcyh0aW1lc3RhbXAuZ2V0U2Vjb25kcygpICsgMzApO1xuICBjb25zdCByZWFkV3JpdGVUb2tlbiA9IGdldFRva2VuRnJvbU9wdGlvbnNPckVudih7IHRva2VuIH0pO1xuICBjb25zdCBbLCAsICwgc3RvcmVJZCA9IG51bGxdID0gcmVhZFdyaXRlVG9rZW4uc3BsaXQoXCJfXCIpO1xuICBpZiAoIXN0b3JlSWQpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgdG9rZW4gPyBcIkludmFsaWQgYHRva2VuYCBwYXJhbWV0ZXJcIiA6IFwiSW52YWxpZCBgQkxPQl9SRUFEX1dSSVRFX1RPS0VOYFwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmZyb20oXG4gICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgLi4uYXJnc1dpdGhvdXRUb2tlbixcbiAgICAgIHZhbGlkVW50aWw6IChfYSA9IGFyZ3NXaXRob3V0VG9rZW4udmFsaWRVbnRpbCkgIT0gbnVsbCA/IF9hIDogdGltZXN0YW1wLmdldFRpbWUoKVxuICAgIH0pXG4gICkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gIGNvbnN0IHNlY3VyZWRLZXkgPSBhd2FpdCBzaWduUGF5bG9hZChwYXlsb2FkLCByZWFkV3JpdGVUb2tlbik7XG4gIGlmICghc2VjdXJlZEtleSkge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJVbmFibGUgdG8gc2lnbiBjbGllbnQgdG9rZW5cIik7XG4gIH1cbiAgcmV0dXJuIGB2ZXJjZWxfYmxvYl9jbGllbnRfJHtzdG9yZUlkfV8ke0J1ZmZlci5mcm9tKFxuICAgIGAke3NlY3VyZWRLZXl9LiR7cGF5bG9hZH1gXG4gICkudG9TdHJpbmcoXCJiYXNlNjRcIil9YDtcbn1cbmV4cG9ydCB7XG4gIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkLFxuICBjcmVhdGVNdWx0aXBhcnRVcGxvYWQsXG4gIGNyZWF0ZU11bHRpcGFydFVwbG9hZGVyLFxuICBnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuLFxuICBnZXRQYXlsb2FkRnJvbUNsaWVudFRva2VuLFxuICBoYW5kbGVVcGxvYWQsXG4gIHB1dCxcbiAgdXBsb2FkLFxuICB1cGxvYWRQYXJ0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@vercel+blob@0.22.3/node_modules/@vercel/blob/dist/client.js\n");

/***/ })

};
;